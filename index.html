<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>School Device Audit ‚Äî Student/Class/Device Database</title>

  <!-- SheetJS (XLSX) for reading Excel files -->
  <script src="https://cdn.sheetjs.com/xlsx-0.20.2/package/dist/xlsx.full.min.js"></script>
  <script>
    window.addEventListener('error', function (e) {
      if (e.target && e.target.src && e.target.src.includes('xlsx.full.min.js')) {
        console.error('Failed to load SheetJS library. Please check your internet connection or ensure cdn.sheetjs.com is not blocked.');
      }
    }, true);
  </script>

  <style>
    :root {
      --bg: #f1f5f9;
      --card: #ffffff;
      --card2: #f8fafc;
      --text: #0f172a;
      --muted: #64748b;
      --line: #e2e8f0;
      --brand: #2563eb;
      --good: #10b981;
      --warn: #f59e0b;
      --bad: #ef4444;

      --radius: 12px;
      --shadow: 0 4px 12px rgba(0, 0, 0, .05);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }

    * {
      box-sizing: border-box
    }

    body {
      margin: 0;
      font-family: var(--sans);
      background-color: var(--bg);
      color: var(--text);
      line-height: 1.5;
    }

    header {
      padding: 16px 18px;
      border-bottom: 1px solid var(--line);
      position: sticky;
      top: 0;
      background: rgba(255, 255, 255, .8);
      backdrop-filter: blur(12px);
      z-index: 100;
    }

    .wrap {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 12px;
    }

    .row {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
    }

    h1 {
      font-size: 18px;
      margin: 0;
      letter-spacing: .2px;
    }

    .pill {
      font-size: 12px;
      color: var(--muted);
      border: 1px solid rgba(255, 255, 255, .12);
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(255, 255, 255, .04);
    }

    main {
      padding: 18px 0 80px;
    }

    .grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 20px;
    }

    @media (max-width: 980px) {
      .grid {
        grid-template-columns: 1fr;
      }
    }

    .dashboard-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 20px;
    }

    .card {
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    .card .hd {
      padding: 12px 16px;
      border-bottom: 1px solid var(--line);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      background: var(--card2);
    }

    .card .hd h2 {
      font-size: 14px;
      margin: 0;
      color: var(--text)
    }

    .card .hd small {
      color: var(--muted)
    }

    .card .bd {
      padding: 14px;
    }

    .muted {
      color: var(--muted)
    }

    .btn {
      background: white;
      border: 1px solid var(--line);
      color: var(--text);
      padding: 8px 14px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      transition: all .2s;
      display: inline-flex;
      gap: 8px;
      align-items: center;
      user-select: none;
      font-size: 13px;
    }

    .btn:hover {
      background: var(--card2);
      border-color: var(--brand);
      color: var(--brand);
    }

    .btn.brand {
      background: var(--brand);
      color: white;
      border-color: var(--brand);
    }

    .btn.brand:hover {
      opacity: .9;
      color: white;
    }

    .btn.danger {
      color: var(--bad);
      border-color: var(--bad);
    }

    .btn.good {
      color: var(--good);
      border-color: var(--good);
    }

    input[type="file"] {
      display: none;
    }

    .fileRow {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
      padding: 10px 12px;
      border: 1px dashed var(--line);
      border-radius: 14px;
      background: var(--card2);
      margin-bottom: 10px;
    }

    .fileRow b {
      font-size: 13px;
    }

    .fileRow .meta {
      font-family: var(--mono);
      font-size: 12px;
      color: var(--muted);
      word-break: break-word;
    }

    .fileRow .spacer {
      flex: 1;
    }

    .kpi {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 10px;
    }

    @media (max-width: 600px) {
      .kpi {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    .kpi .box {
      padding: 12px 12px;
      border-radius: 14px;
      border: 1px solid var(--line);
      background: var(--card2);
    }

    .kpi .n {
      font-size: 20px;
      font-weight: 800;
      letter-spacing: .3px;
    }

    .kpi .l {
      font-size: 12px;
      color: var(--muted);
      margin-top: 2px;
    }

    .tag {
      font-size: 11px;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, .14);
      color: var(--muted)
    }

    .tag.good {
      background: #ecfdf5;
      color: #065f46;
      border-color: #a7f3d0;
    }

    .tag.warn {
      background: #fffbeb;
      color: #92400e;
      border-color: #fde68a;
    }

    .tag.bad {
      background: #fef2f2;
      color: #991b1b;
      border-color: #fecaca;
    }

    .controls {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
      margin-top: 12px;
    }

    @media (max-width: 980px) {
      .controls {
        grid-template-columns: 1fr;
      }
    }

    label {
      font-size: 12px;
      color: var(--muted);
      display: block;
      margin-bottom: 6px;
    }

    select,
    input[type="text"],
    input[type="search"] {
      width: 100%;
      padding: 10px 10px;
      border-radius: 12px;
      border: 1px solid var(--line);
      background: white;
      color: var(--text);
      outline: none;
    }

    select:focus,
    input:focus {
      border-color: rgba(116, 167, 255, .55);
      box-shadow: 0 0 0 3px rgba(116, 167, 255, .18);
    }

    .tabs {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      padding: 10px 12px;
      border-bottom: 1px solid var(--line);
      background: var(--card2);
    }

    .tab {
      padding: 9px 12px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: white;
      cursor: pointer;
      font-weight: 700;
      font-size: 12px;
      color: var(--muted);
    }

    .tab.nav {
      background: transparent;
      border: none;
      color: var(--muted);
      padding: 8px 16px;
      border-radius: 8px;
    }

    .tab.nav.active {
      background: var(--card);
      color: var(--brand);
      box-shadow: 0 2px 5px rgba(0, 0, 0, .05);
    }

    .tableWrap {
      padding: 0 12px 12px;
    }

    table {
      width: 100%;
      border-collapse: separate;
      border-spacing: 0;
      overflow: hidden;
      border-radius: 14px;
      border: 1px solid var(--line);
      background: white;
    }

    .table-container {
      position: relative;
      overflow: auto;
      max-height: calc(100vh - 350px);
      border: 1px solid var(--line);
      border-radius: 8px;
      background: var(--bg);
    }

    thead th {
      position: sticky;
      top: 0;
      z-index: 10;
      background: var(--bg);
      box-shadow: 0 1px 0 var(--line);
      backdrop-filter: blur(8px);
      font-size: 11px;
      text-align: left;
      color: var(--muted);
      padding: 6px 8px;
      border-bottom: 2px solid var(--line);
    }

    /* Support two-row sticky header */
    #theadRow th[rowspan="2"] {
      top: 0;
      height: 64px;
      z-index: 21;
    }

    #theadSubRow th {
      top: 31px;
      z-index: 20;
    }

    .modal-hd {
      position: sticky;
      top: 0;
      background: var(--card);
      z-index: 110;
      border-bottom: 1px solid var(--line);
      padding: 12px 16px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 0;
    }

    .scroll-container {
      overflow: auto;
      max-height: calc(100vh - 320px);
      position: relative;
    }

    .sortable {
      cursor: pointer;
      user-select: none;
    }

    .sortable:hover {
      background: var(--line) !important;
      color: var(--brand);
    }

    .sort-icon {
      font-size: 8px;
      margin-left: 3px;
    }

    tbody tr:hover {
      background: rgba(116, 167, 255, .06)
    }

    .mini {
      font-size: 12px;
      color: var(--muted)
    }

    .nowrap {
      white-space: nowrap
    }

    .right {
      text-align: right
    }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid rgba(0, 0, 0, .08);
      font-size: 11px;
      background: var(--card2);
    }

    .mini {
      font-size: 11px;
      color: var(--muted);
    }

    .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }

    .dot.good {
      background: var(--good)
    }

    .dot.warn {
      background: var(--warn)
    }

    .dot.bad {
      background: var(--bad)
    }

    .auditBox {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }

    .auditBox input[type="checkbox"] {
      transform: scale(1.15);
    }

    .footerBar {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      margin-top: 12px;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid var(--line);
      background: var(--card2);
    }

    .hint {
      font-size: 12px;
      color: var(--muted);
      line-height: 1.35;
    }

    .import-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
      margin-top: 10px;
    }

    .import-card {
      padding: 12px;
      border-radius: 12px;
      border: 1px solid var(--line);
      background: var(--card2);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    /* Print */
    @media print {

      header,
      .leftPane,
      .footerBar,
      .tabs {
        display: none !important;
      }

      body {
        background: #fff;
        color: #000
      }

      .card {
        box-shadow: none;
        border: none
      }

      table {
        border: 1px solid #999;
        background: #fff
      }

      thead th {
        background: #eee;
        color: #000
      }

      tbody td {
        border-bottom: 1px solid #ddd
      }

      .chip,
      .tag {
        border: 1px solid #ddd;
        color: #000
      }
    }

    .class-cell:hover {
      background: rgba(37, 99, 235, 0.1) !important;
    }

    td,
    th {
      border: 1px solid var(--line);
    }

    #timetableGrid th {
      background: var(--card2);
      padding: 12px;
    }

    #timetableGrid td {
      height: 60px;
      vertical-align: middle;
    }
  </style>
</head>

<body>
  <header>
    <div class="wrap row" style="justify-content:space-between;">
      <div class="row" style="gap:15px;">
        <h1 style="font-size:22px; color:var(--brand);">RSHS Audit</h1>
        <nav class="row"
          style="gap:5px; background:var(--bg); padding:4px; border-radius:10px; border:1px solid var(--line);">
          <button class="tab nav active" onclick="showSection('dashboard')">üìä Dashboard</button>
          <button class="tab nav" onclick="showSection('timetable')">üìÖ Timetable</button>
          <button class="tab nav" onclick="showSection('equity')">üíº Equity Tracking</button>
          <button class="tab nav" onclick="showSection('config')">‚öôÔ∏è Imports</button>
        </nav>
      </div>
      <div class="row">
        <div id="connectionWarning"
          style="display:none; align-items:center; gap:8px; background:rgba(239, 68, 68, 0.1); padding:4px 12px; border-radius:8px; border:1px solid var(--bad); color:var(--bad); font-weight:bold; font-size:13px; cursor:pointer;"
          onclick="syncProjectFolder(state._projectFolderHandle, true)">
          ‚ö†Ô∏è Database Disconnected - Click to Reconnect
        </div>
        <span class="mini muted" id="saveStatus">Auto-save: ON</span>
        <span id="saveTag" style="display:none;"></span>
        <button class="btn secondary" id="btnExportCsv">‚¨áÔ∏è CSV</button>
        <button class="btn secondary" onclick="window.print()">üñ®Ô∏è Print</button>
      </div>
    </div>
  </header>

  <main id="section-config" style="display:none;">
    <div class="wrap">
      <div class="grid">
        <!-- LEFT: Imports -->
        <div class="leftPane">
          <div class="card" style="margin-bottom: 20px; border: 1px solid var(--brand);">
            <div class="hd" style="background: rgba(37, 99, 235, 0.05);">
              <div>
                <h2 style="color: var(--brand);">üìÇ Database & Settings Connection</h2>
                <small class="muted">The app reads from <b>MasterDB.csv</b> and <b>Setting.json</b> in your chosen
                  folder.</small>
              </div>
            </div>
            <div class="bd">
              <div class="row" style="gap:10px; margin-bottom:15px;">
                <button class="btn brand" onclick="selectProjectFolder()">üìÇ Connect Project Folder</button>
                <div id="projectFolderStatus" class="mini muted">Not connected</div>
                <button id="pjReconnectBtn" class="btn good" style="display:none;"
                  onclick="syncProjectFolder(state._projectFolderHandle, true)">üîó Re-establish Connection</button>
              </div>
              <div class="hint" style="margin-bottom:15px;">
                Connecting the folder ensures your data is automatically saved to <b>MasterDB.csv</b> and backups are
                created in the <b>Backup</b> subfolder.
              </div>

              <label><b>Smart Scan Prefixes</b> (Used for periodic exports/imports)</label>
              <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px;">
                <div>
                  <label>Student DB Prefix</label>
                  <input type="text" id="pre_student" placeholder="Parent Mobile-Email Contact Export"
                    onchange="state.prefixes.student = this.value; saveLocal('prefix-change')">
                </div>
                <div>
                  <label>Student Classes Prefix</label>
                  <input type="text" id="pre_sclass" placeholder="ExportStudentClass"
                    onchange="state.prefixes.sclass = this.value; saveLocal('prefix-change')">
                </div>
                <div>
                  <label>Timetable Prefix</label>
                  <input type="text" id="pre_timetable" placeholder="ExportTimetable"
                    onchange="state.prefixes.timetable = this.value; saveLocal('prefix-change')">
                </div>
                <div>
                  <label>Device Info Prefix</label>
                  <input type="text" id="pre_device" placeholder="student data"
                    onchange="state.prefixes.device = this.value; saveLocal('prefix-change')">
                </div>
              </div>
            </div>
          </div>

          <div class="card">

            <div class="hd">
              <div>
                <h2>1) Import spreadsheets</h2>
                <small class="muted">Load your Excel files. Then map columns once.</small>
              </div>
              <span class="tag" id="statusTag">Not loaded</span>
            </div>
            <div class="bd">
              <div class="fileRow">
                <div>
                  <b>Student info DB</b>
                  <div class="meta" id="metaStudent">No file</div>
                </div>
                <div class="import-grid">
                  <div class="import-card">
                    <span class="mini muted">Student Info (Master)</span>
                    <div class="row" style="gap:5px; margin-top:5px;">
                      <button class="btn secondary mini" onclick="linkFile('student')">üìÅ Link File</button>
                      <input type="file" id="fileStudentLegacy" style="display:none;"
                        onchange="handleFileSelect(event, 'student')">
                      <button class="btn secondary mini"
                        onclick="document.getElementById('fileStudentLegacy').click()">üìÑ Select</button>
                    </div>
                    <div id="meta-student" class="mini muted" style="margin-top:4px;">No file linked</div>
                  </div>

                  <div class="import-card">
                    <span class="mini muted">Student Classes</span>
                    <div class="row" style="gap:5px; margin-top:5px;">
                      <button class="btn secondary mini" onclick="linkFile('sclass')">üìÅ Link File</button>
                      <input type="file" id="fileSclassLegacy" style="display:none;"
                        onchange="handleFileSelect(event, 'sclass')">
                      <button class="btn secondary mini"
                        onclick="document.getElementById('fileSclassLegacy').click()">üìÑ Select</button>
                    </div>
                    <div id="meta-sclass" class="mini muted" style="margin-top:4px;">No file linked</div>
                  </div>

                  <div class="import-card">
                    <span class="mini muted">Timetable</span>
                    <div class="row" style="gap:5px; margin-top:5px;">
                      <button class="btn secondary mini" onclick="linkFile('timetable')">üìÅ Link File</button>
                      <input type="file" id="fileTimetableLegacy" style="display:none;"
                        onchange="handleFileSelect(event, 'timetable')">
                      <button class="btn secondary mini"
                        onclick="document.getElementById('fileTimetableLegacy').click()">üìÑ Select</button>
                    </div>
                    <div id="meta-timetable" class="mini muted" style="margin-top:4px;">No file linked</div>
                  </div>

                  <div class="import-card">
                    <span class="mini muted">Device Info (Optional)</span>
                    <div class="row" style="gap:5px; margin-top:5px;">
                      <button class="btn secondary mini" onclick="linkFile('device')">üìÅ Link File</button>
                      <input type="file" id="fileDeviceLegacy" style="display:none;"
                        onchange="handleFileSelect(event, 'device')">
                      <button class="btn secondary mini"
                        onclick="document.getElementById('fileDeviceLegacy').click()">üìÑ Select</button>
                    </div>
                    <div id="meta-device" class="mini muted" style="margin-top:4px;">No file linked</div>
                  </div>
                </div>

                <div class="row" style="margin-top:10px; justify-content:space-between; flex-wrap:wrap; gap:10px;">
                  <div class="row" style="gap:10px;">
                    <button class="btn good" id="btnMapMerge">üîó Map & Merge</button>
                  </div>
                  <div class="row" style="gap:10px;">
                    <div id="fileSyncStatus" class="mini muted" style="margin-top:4px; font-style:italic;">External
                      Sync: Forced to MasterDB.csv</div>

                    <div style="margin-top:12px;" class="hint">
                      <div><b>How it joins:</b></div>
                      <ul style="margin:6px 0 0 18px;padding:0;color:var(--muted)">
                        <li>Student info DB is the ‚Äúmaster list‚Äù.</li>
                        <li>Other files connect using <span style="font-family:var(--mono);">EQ_Id</span>.</li>
                        <li>Student class can link to Timetable via class code/name (you‚Äôll choose the columns).</li>
                        <li>Device info can connect using <span style="font-family:var(--mono);">EQ_Id</span> OR
                          serial/username
                          (you‚Äôll choose).</li>
                      </ul>
                    </div>
                  </div>
                </div>

                <!-- Persistence settings moved to top -->

                <div class="card" style="margin-top:14px;">
                  <div class="hd">
                    <h2>2) Column mapping</h2>
                    <small class="muted">Pick which columns match your files.</small>
                  </div>
                  <div class="bd" id="mappingArea">
                    <div class="muted" style="font-size:13px;">
                      Import files first, then click <b>Map & Merge</b>.
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
  </main>

  <main id="section-timetable" style="display:none;">
    <div class="wrap">
      <div class="card">
        <div class="hd">
          <div>
            <h2>Weekly Audit Timetable</h2>
            <small class="muted">Periods HC to 8</small>
          </div>
          <div class="row" style="gap:10px;">
            <div class="row" style="gap:5px; margin-right: 15px;">
              <div class="chip"
                style="background:rgba(37, 99, 235, 0.1); color:var(--brand); border-color:var(--brand);">
                In Audit: <b id="ttKpiInAudit">0</b>
              </div>
              <div class="chip"
                style="background:rgba(100, 116, 139, 0.1); color:var(--muted); border-color:var(--muted);">
                Not In Audit: <b id="ttKpiNotInAudit">0</b>
              </div>
            </div>
            <button class="btn good mini" onclick="showAutoFillModal()"
              title="Greedily add classes to cover students not yet in audit">üéØ Auto-Fill Missing</button>

            <button class="btn secondary mini" onclick="printChosenGroups('auto', 'Auto-Filled')"
              title="Print only the classes automatically added by the Auto-Fill tool">üñ®Ô∏è Print Auto ‚ú®</button>
            <button class="btn secondary" onclick="showBulkSelectModal()">üìã Bulk Select Classes</button>
            <button class="btn danger mini" onclick="clearAllChosen()">üóëÔ∏è Clear Selections</button>
            <button class="btn brand" onclick="renderTimetable()">üîÑ Refresh Timetable</button>
          </div>
        </div>
        <div class="bd" style="overflow-x:auto;">
          <table id="timetableGrid" style="text-align:center; min-width:800px;">
            <thead>
              <tr>
                <th style="width:100px;">Period</th>
                <th>Monday</th>
                <th>Tuesday</th>
                <th>Wednesday</th>
                <th>Thursday</th>
                <th>Friday</th>
              </tr>
            </thead>
            <tbody id="timetableBody">
              <!-- Generated by JS -->
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </main>

  <main id="section-equity" style="display:none;">
    <div class="wrap">
      <div class="card">
        <div class="hd">
          <div>
            <h2>Equity Device Tracking</h2>
            <small class="muted">Workflow for requested equity devices</small>
          </div>
          <div class="row">
            <button class="btn brand mini" onclick="renderEquityTracking()">üîÑ Refresh List</button>
          </div>
        </div>
        <div class="bd">
          <div class="tableWrap">
            <table style="width:100%;">
              <thead>
                <tr>
                  <th>Student Info</th>
                  <th>Current Process Status</th>
                  <th>Contact</th>
                  <th>Return Date</th>
                  <th>Notes</th>
                </tr>
              </thead>
              <tbody id="equityTrackingBody">
                <!-- JS -->
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
  </main>

  <div id="modalSchedule" class="modal" style="display:none;">
    <div class="modal-content" style="max-width:400px;">
      <h3>üìÖ Auto-fill Audit Selection</h3>
      <p class="mini muted">Select the schedule to automatically check students for auditing based on their timetable.
      </p>

      <div style="margin-bottom:15px;">
        <b>Days</b>
        <div class="row" style="gap:5px; flex-wrap:wrap; margin-top:5px;" id="scheduleDays">
          <!-- filled by js -->
        </div>
      </div>

      <div style="margin-bottom:15px;">
        <b>Periods</b>
        <div class="row" style="gap:5px; flex-wrap:wrap; margin-top:5px;" id="schedulePeriods">
          <!-- filled by js -->
        </div>
      </div>

      <div class="row" style="justify-content:flex-end; gap:10px; margin-top:20px;">
        <button class="btn" onclick="closeModal('modalSchedule')">Cancel</button>
        <button class="btn good" onclick="runScheduleAutoFill()">Apply Selection</button>
      </div>
    </div>
  </div>

  <div id="modalOverlay"
    style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.4); z-index:1000; align-items:center; justify-content:center;">
    <div class="card" style="width:500px; max-width:90vw; max-height:80vh; overflow:auto;">
      <div class="modal-hd">
        <h2 id="modalTitle">Select Class</h2>
        <button class="btn secondary" onclick="closeModal()">‚úï</button>
      </div>
      <div class="bd" id="modalBody"></div>
    </div>
  </div>

  <main id="section-dashboard">
    <div class="wrap">
      <div class="card">
        <div class="hd">
          <div>
            <h2>Device audit dashboard</h2>
            <small class="muted" id="subTitle">Import + merge to begin.</small>
          </div>
          <div class="row">
            <span class="tag" id="saveTag">Local save: idle</span>
          </div>
        </div>

        <div class="bd">
          <div class="kpi">
            <div class="box">
              <div class="n" id="kpiStudents" style="color:var(--brand)">0</div>
              <div class="l">Total students</div>
            </div>
            <div class="box">
              <div class="n" id="kpiMissing" style="color:var(--bad)">0</div>
              <div class="l">Missing device</div>
            </div>
            <div class="box">
              <div class="n" id="kpiOverdue" style="color:var(--bad)">0</div>
              <div class="l">Overdue devices</div>
            </div>
            <div class="box">
              <div class="n" id="kpiIssues" style="color:var(--warn)">0</div>
              <div class="l">Audit issues</div>
            </div>
            <div class="box">
              <div class="n" id="kpiAudited" style="color:var(--good)">0</div>
              <div class="l">Audited & Connected</div>
            </div>
          </div>


          <div class="controls">
            <div>
              <label>View</label>
              <select id="viewMode">
                <option value="students">Students (audit list)</option>
                <option value="classes">Classes (summary)</option>
                <option value="year">Year levels (summary)</option>
                <option value="devices">Devices (raw/linked)</option>
              </select>
            </div>

            <div>
              <label>Filter: Year level</label>
              <select id="filterYear">
                <option value="">All years</option>
              </select>
            </div>

            <div>
              <label>Filter: Class</label>
              <select id="filterClass">
                <option value="">All classes</option>
              </select>
            </div>

            <div>
              <label>Device status</label>
              <select id="filterDevice">
                <option value="">All</option>
                <option value="missing">Missing / unknown device</option>
                <option value="has">Has a device</option>
                <option value="notConnected">Not connected to network</option>
                <option value="notWorking">Not working</option>
                <option value="issues">Any issues (not connected OR not working)</option>
              </select>
            </div>

            <div class="row" style="gap:10px;">
              <div class="row"
                style="border:1px solid var(--line); padding:4px 8px; border-radius:8px; background:white;">
                <input type="text" id="searchBox" placeholder="Search student/ID/serial..."
                  style="border:none; outline:none; font-size:13px; width:200px;"
                  onkeyup="if(event.key==='Enter') refreshFilters()">
                <button class="btn primary" style="padding:4px 12px; font-size:12px;"
                  onclick="refreshFilters()">Search</button>
              </div>
              <button class="btn secondary" id="btnQuickSave">üíæ Save now</button>
            </div>

            <div class="row" style="align-items:end; gap:10px;">
              <button class="btn secondary" id="btnQuickSave">üíæ Save now</button>
              <button class="btn brand" onclick="emailParentsByStatus('selected')">
                üìß Email Selected (<span id="selectedCount">0</span>)
              </button>
            </div>
          </div>
        </div>

        <div class="tabs" id="tabsInfo" style="display:none;">
          <div class="muted" style="font-size:12px;padding:6px 6px;">
            Tip: In Students view, you can tick <b>Working</b> and <b>Connected</b> to record your audit.
          </div>
        </div>

        <div class="tableWrap">
          <div class="footerBar">
            <div class="hint" id="viewHint">No data yet.</div>
            <div class="row">
              <span class="mini" id="lastMerged">Not merged</span>
            </div>
          </div>

          <div id="dashboard" class="tab-content active">
            <div class="table-container">
              <table>
                <thead id="theadRow"></thead>
                <tbody id="tbody"></tbody>
              </table>
            </div>
          </div>

          <div class="footerBar">
            <div class="hint">
              <b>Privacy note:</b> This runs in your browser. No uploads to a server. Data stays on this device unless
              you export.
            </div>
            <div class="row">
              <span class="mini">Rows shown: <b id="rowsShown">0</b></span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>

  <script>
    /**
     * School Device Audit ‚Äî single-file app
     * - Imports XLSX/CSV via SheetJS
     * - Column mapping + merging
     * - Filtering views + editable audit flags
     * - Export CSV + Print
     *
     * Data model:
     *  - studentInfoRows: array of objects (master list)
     *  - studentClassRows: array of objects
     *  - timetableRows: array of objects
     *  - deviceRows: array of objects (optional)
     *  - mergedStudents: array of unified student records
     *
     * Persistence: localStorage
     */

    let LS_KEY_BASE = "deviceAuditApp.v1";
    let CURRENT_DB_SUFFIX = localStorage.getItem("deviceAuditApp.currentDbSuffix") || "default";

    /** IndexedDB Wrapper for larger storage **/
    const DB_NAME = "deviceAuditDB_v3"; // Bumped version for fresh start
    const STORE_NAME = "states";
    const DB_VERSION = 1;

    function openDB() {
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(DB_NAME, DB_VERSION);
        req.onupgradeneeded = e => { if (!e.target.result.objectStoreNames.contains(STORE_NAME)) e.target.result.createObjectStore(STORE_NAME); };
        req.onsuccess = e => resolve(e.target.result);
        req.onerror = e => reject(e.target.error);
      });
    }
    async function dbGet(k) {
      const db = await openDB();
      return new Promise((resolve, reject) => {
        const t = db.transaction(STORE_NAME, "readonly");
        const s = t.objectStore(STORE_NAME).get(k);
        s.onsuccess = () => resolve(s.result);
        s.onerror = () => reject(s.error);
      });
    }
    async function dbSet(k, v) {
      const db = await openDB();
      return new Promise((resolve, reject) => {
        const t = db.transaction(STORE_NAME, "readwrite");
        const s = t.objectStore(STORE_NAME).put(v, k);
        s.onsuccess = () => resolve();
        s.onerror = () => reject(s.error);
      });
    }
    async function dbDel(k) {
      const db = await openDB();
      return new Promise((resolve, reject) => {
        const t = db.transaction(STORE_NAME, "readwrite");
        const s = t.objectStore(STORE_NAME).delete(k);
        s.onsuccess = () => resolve();
        s.onerror = () => reject(s.error);
      });
    }




    const state = {
      dbSuffix: CURRENT_DB_SUFFIX,
      filesMeta: { student: null, sclass: null, timetable: null, device: null },
      raw: { student: [], sclass: [], timetable: [], device: [] }, // Renamed from studentInfo to student for consistency
      columns: { student: [], sclass: [], timetable: [], device: [] }, // Renamed
      mapping: null,
      merged: { students: [], devices: [] },
      _audit: {},
      _equityStatus: {}, // { eqid: statusNumber }
      _auditHistory: {}, // { eqid: [ { date, text, author } ] }
      chosenClasses: {},
      showChosenOnly: true,
      lastMergedAt: null,
      sortBy: 'LastName',
      sortDir: 'asc',
      selectedStudents: {}, // { eqid: true }
      _handles: {},         // { student: FileSystemFileHandle, sclass, timetable, device }
      _projectFolderHandle: null,
      _masterDbHandle: null,
      _settingsFileHandle: null,
      _sourceDirHandle: null,
      prefixes: {
        student: "Parent Mobile-Email Contact Export",
        sclass: "ExportStudentClass",
        timetable: "ExportTimetable",
        device: "student data"
      },
      bulkFilters: {
        prefix: "ENG",
        days: ['Tuesday', 'Wednesday', 'Thursday', 'Friday'],
        periods: ['1', '2', '3', '4']
      },
      backupSettings: {
        autoOnOpen: localStorage.getItem("deviceAuditApp.autoBackup") === "true",
        folderName: null
      }
    };

    const els = {
      metaStudent: document.getElementById("meta-student"), // Updated ID
      metaClass: document.getElementById("meta-sclass"),    // Updated ID
      metaTimetable: document.getElementById("meta-timetable"), // Updated ID
      metaDevice: document.getElementById("meta-device"),   // Updated ID
      statusTag: document.getElementById("statusTag"),
      saveTag: document.getElementById("saveTag"),
      mappingArea: document.getElementById("mappingArea"),
      subTitle: document.getElementById("subTitle"),

      viewMode: document.getElementById("viewMode"),
      filterYear: document.getElementById("filterYear"),
      filterClass: document.getElementById("filterClass"),
      filterDevice: document.getElementById("filterDevice"),
      searchBox: document.getElementById("searchBox"),

      btnMapMerge: document.getElementById("btnMapMerge"),
      btnClear: document.getElementById("btnClear"),
      btnExportCsv: document.getElementById("btnExportCsv"),
      btnQuickSave: document.getElementById("btnQuickSave"),

      theadRow: document.getElementById("theadRow"),
      tbody: document.getElementById("tbody"),
      rowsShown: document.getElementById("rowsShown"),
      lastMerged: document.getElementById("lastMerged"),
      viewHint: document.getElementById("viewHint"),
      tabsInfo: document.getElementById("tabsInfo"),

      kpiStudents: document.getElementById("kpiStudents"),
      kpiMissing: document.getElementById("kpiMissing"),
      kpiIssues: document.getElementById("kpiIssues"),
      kpiAudited: document.getElementById("kpiAudited"),
      ttKpiInAudit: document.getElementById("ttKpiInAudit"),
      ttKpiNotInAudit: document.getElementById("ttKpiNotInAudit"),
    };

    function setTag(tagEl, text, kind = "") {
      tagEl.textContent = text;
      tagEl.className = "tag" + (kind ? " " + kind : "");
    }

    function nowISO() {
      const d = new Date();
      return d.toISOString();
    }

    function friendlyTime(iso) {
      try {
        const d = new Date(iso);
        return d.toLocaleString();
      } catch { return iso; }
    }

    async function saveLocal(reason = "auto") {
      const dbKey = LS_KEY_BASE + "." + state.dbSuffix;
      localStorage.setItem("deviceAuditApp.currentDbSuffix", state.dbSuffix);

      const payload = {
        version: 1,
        savedAt: nowISO(),
        reason,
        state
      };

      let idbSuccess = false;
      try {
        await dbSet(dbKey, payload);
        idbSuccess = true;
      } catch (e) { console.error("IDB save failed", e); }

      let lsSuccess = false;
      try {
        // Only save a lightweight version to localStorage to avoid exceeding quota
        localStorage.setItem(dbKey, JSON.stringify({ ...payload, state: { ...state, raw: {}, merged: {} } }));
        lsSuccess = true;
      } catch (e) { }

      // Save to Master DB (CSV)
      if (state._masterDbHandle) {
        saveToMasterDB();
      }

      // Save to Settings (JSON)
      if (state._settingsFileHandle) {
        saveSettings();
      }

      let extSuccess = false;
      if (state._dbFileHandle) {
        try {
          if (await state._dbFileHandle.queryPermission({ mode: 'readwrite' }) === 'granted') {
            const writable = await state._dbFileHandle.createWritable();
            await writable.write(JSON.stringify(payload, null, 2));
            await writable.close();
            extSuccess = true;
          }
        } catch (e) { }
      }

      const s = document.getElementById("saveStatus");
      if (s) {
        if (idbSuccess || lsSuccess || extSuccess) {
          s.textContent = "Saved " + new Date().toLocaleTimeString() + (extSuccess ? " (+File)" : "");
          s.style.color = "var(--good)";
        } else {
          s.textContent = "SAVE FAILED";
          s.style.color = "var(--bad)";
        }
        setTimeout(() => { s.textContent = "Auto-save: ON"; s.style.color = ""; }, 3000);
      }
    }

    async function importJsonBackup(event) {
      const file = event.target.files[0];
      if (!file) return;
      try {
        const text = await file.text();
        const payload = JSON.parse(text);
        if (payload?.state) {
          const migratedState = migrateState(payload.state);
          Object.assign(state, migratedState);
          state.dbSuffix = CURRENT_DB_SUFFIX;
          alert("Backup restored successfully!");
          await saveLocal("restore");
          location.reload();
        } else {
          alert("Invalid backup file (missing state).");
        }
      } catch (e) {
        alert("Failed to read backup: " + e.message);
      }
    }
    window.importJsonBackup = importJsonBackup;

    function migrateState(s) {
      if (!s) return s;
      // Migrate 'raw'
      if (s.raw && s.raw.studentInfo && !s.raw.student) {
        s.raw.student = s.raw.studentInfo;
        delete s.raw.studentInfo;
      }
      // Migrate 'columns'
      if (s.columns && s.columns.studentInfo && !s.columns.student) {
        s.columns.student = s.columns.studentInfo;
        delete s.columns.studentInfo;
      }
      // Migrate 'filesMeta'
      if (s.filesMeta && s.filesMeta.studentInfo && !s.filesMeta.student) {
        s.filesMeta.student = s.filesMeta.studentInfo;
        delete s.filesMeta.studentInfo;
      }
      return s;
    }

    function showScheduleMenu() {
      const tt = state.raw.timetable || [];
      const m = state.mapping;
      if (!tt.length || !m?.tt_day || !m?.tt_period) {
        alert("Please import Timetable and map Day/Period columns first.");
        return;
      }

      const days = [...new Set(tt.map(r => (r[m.tt_day] || "").toString().trim()))].sort();
      const periods = [...new Set(tt.map(r => (r[m.tt_period] || "").toString().trim()))].sort();

      const dArea = document.getElementById("scheduleDays");
      const pArea = document.getElementById("schedulePeriods");

      dArea.innerHTML = days.map(d => `<label class="btn secondary mini" style="padding:4px 8px; font-size:11px;"><input type="checkbox" name="schDay" value="${escapeHtml(d)}"> ${escapeHtml(d)}</label>`).join("");
      pArea.innerHTML = periods.map(p => `<label class="btn secondary mini" style="padding:4px 8px; font-size:11px;"><input type="checkbox" name="schPeriod" value="${escapeHtml(p)}"> ${escapeHtml(p)}</label>`).join("");

      document.getElementById("modalSchedule").style.display = "flex";
      document.getElementById("modalOverlay").style.display = "none";
    }
    window.showScheduleMenu = showScheduleMenu;

    function runScheduleAutoFill() {
      const selectedDays = Array.from(document.querySelectorAll('input[name="schDay"]:checked')).map(i => i.value);
      const selectedPeriods = Array.from(document.querySelectorAll('input[name="schPeriod"]:checked')).map(i => i.value);

      if (!selectedDays.length || !selectedPeriods.length) {
        alert("Select at least one day and one period.");
        return;
      }

      const m = state.mapping;
      const tt = state.raw.timetable || [];
      const codes = new Set();
      for (const r of tt) {
        const d = (r[m.tt_day] || "").toString().trim();
        const p = (r[m.tt_period] || "").toString().trim();
        if (selectedDays.indexOf(d) !== -1 && selectedPeriods.indexOf(p) !== -1) {
          const code = (r[m.tt_classcode] || "").toString().trim();
          if (code) codes.add(code);
        }
      }

      const matches = state.merged.students.filter(s => {
        return (s.Classes || []).some(c => codes.has(c.classCode));
      });

      matches.forEach(s => state.selectedStudents[s.EQ_Id] = true);
      closeModal('modalSchedule');
      render();
      alert(`Selected ${matches.length} students matching schedule.`);
    }
    window.runScheduleAutoFill = runScheduleAutoFill;


    function showSection(id) {
      document.querySelectorAll('main').forEach(m => m.style.display = 'none');
      document.getElementById('section-' + id).style.display = 'block';
      document.querySelectorAll('.tab.nav').forEach(b => {
        b.classList.toggle('active', b.getAttribute('onclick').includes(id));
      });
      if (id === 'timetable') renderTimetable();
      if (id === 'equity') renderEquityTracking();
      saveLocal("tab-switch");
    }

    const PERIODS_DISP = ["HC", "Lesson 1&2", "Lesson 3&4", "Lesson 5&6", "Lesson 7&8"];
    const PERIOD_MAP = {
      "HC": ["HC"],
      "Lesson 1&2": ["1", "2"],
      "Lesson 3&4": ["3", "4"],
      "Lesson 5&6": ["5", "6"],
      "Lesson 7&8": ["7", "8"]
    };
    const DAYS = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"];

    function looseMatch(val, target) {
      if (!val || !target) return false;
      const v = val.toString().toLowerCase().trim();
      const t = target.toString().toLowerCase().trim();
      if (v === t) return true;
      // Numeric matching: "Period 1" vs "1"
      const vNum = v.replace(/\D/g, '');
      const tNum = t.replace(/\D/g, '');
      if (vNum && tNum && vNum === tNum) return true;
      // Partial matching
      return v.includes(t) || t.includes(v);
    }

    function renderTimetable() {
      const tbody = document.getElementById("timetableBody");
      const thead = document.querySelector("#timetableGrid thead tr");
      const ttRows = state.raw.timetable || [];
      const m = state.mapping;

      if (!m || !m.tt_classcode || !m.tt_period || !m.tt_day) {
        tbody.innerHTML = `<tr><td colspan="6" class="muted" style="padding:40px;">Please map Timetable (Class Code, Period, Day) in the Imports tab first.</td></tr>`;
        return;
      }

      // Calculate totals for summary
      const chosenKeys = Object.keys(state.chosenClasses || {}); // "code|day|period"
      const chosenCodes = new Set(chosenKeys.map(k => k.split("|")[0]));

      const allStudents = state.merged.students || [];
      const studentsInAudit = allStudents.filter(s =>
        (s.Classes || []).some(c => c.classCode && chosenCodes.has(normId(c.classCode)))
      ).length;

      const totalStudents = allStudents.length;
      const studentsNotInAudit = totalStudents - studentsInAudit;

      if (els.ttKpiInAudit) els.ttKpiInAudit.textContent = studentsInAudit;
      if (els.ttKpiNotInAudit) els.ttKpiNotInAudit.textContent = studentsNotInAudit;

      thead.innerHTML = `<th style="width:100px;">
        <div style="display:flex; flex-direction:column; align-items:center; gap:2px;">
          <span style="font-size:10px;">Period</span>
          <div style="display:flex; gap:2px; width:100%;">
            <button class="btn secondary mini" style="font-size:9px; padding:2px 4px; flex:1;" onclick="printChosenGroups('week', 'the week')" title="Print all chosen classes for the week">üñ®Ô∏è Week</button>
            <button class="btn brand mini" style="font-size:9px; padding:2px 4px; flex:1;" onclick="emailTeachers('week', 'the week')" title="Email all teachers scheduled for audit this week">‚úâÔ∏è Week</button>
          </div>
        </div>
      </th>` + DAYS.map(d => `
        <th style="background:var(--card2); border-bottom:2px solid var(--line);">
          <div style="display:flex; flex-direction:column; align-items:center; gap:2px;">
            <span>${d}</span>
            <div style="display:flex; gap:2px;">
              <button class="btn secondary mini" style="font-size:9px; padding:1px 4px;" onclick="printChosenGroups('day', '${d}')" title="Print all chosen classes for this day">üñ®Ô∏è Day</button>
              <button class="btn secondary mini" style="font-size:9px; padding:1px 4px;" onclick="emailTeachers('day', '${d}')" title="Email teachers of chosen classes for this day">‚úâÔ∏è Email</button>
            </div>
          </div>
        </th>
      `).join("");

      let html = "";
      for (const disp of PERIODS_DISP) {
        // Row Header with Print Button
        html += `<tr>
          <th style="background:var(--card2); border-right:2px solid var(--line); font-size:12px; vertical-align:middle;">
            <div style="display:flex; flex-direction:column; align-items:center; gap:2px;">
              <span>${disp}</span>
              <div style="display:flex; gap:2px;">
                <button class="btn secondary mini" style="font-size:9px; padding:1px 4px;" title="Print all chosen classes for this period" onclick="printChosenGroups('period', '${disp}')">üñ®Ô∏è</button>
                <button class="btn secondary mini" style="font-size:9px; padding:1px 4px;" title="Email teachers of chosen classes for this period" onclick="emailTeachers('period', '${disp}')">‚úâÔ∏è</button>
              </div>
            </div>
          </th>`;

        const searchPeriods = PERIOD_MAP[disp] || [];

        for (const d of DAYS) {
          // Find ALL classes in these period matches and day
          const matches = ttRows.filter(r =>
            searchPeriods.some(p => looseMatch(r[m.tt_period], p)) &&
            looseMatch(r[m.tt_day], d)
          ).filter(r => {
            const code = normId(r[m.tt_classcode]);
            const day = r[m.tt_day];
            const period = r[m.tt_period];
            return state.chosenClasses[`${code}|${day}|${period}`];
          });

          if (matches.length > 0) {
            const display = matches;
            const more = "";
            const cellContent = display.map(match => {
              const code = normId(match[m.tt_classcode]);
              const name = m.tt_classname ? match[m.tt_classname] : "";
              const day = match[m.tt_day];
              const p = match[m.tt_period];
              const room = match[m.tt_room] || "";

              const choiceInfo = state.chosenClasses[`${code}|${day}|${p}`];
              const isAuto = typeof choiceInfo === 'object' && choiceInfo.type === 'auto';
              const isLegacyAuto = choiceInfo === 'auto'; // handle legacy strings
              const isChosenAuto = isAuto || isLegacyAuto;
              const autoCount = isAuto ? choiceInfo.count : 0;
              const codeColor = isChosenAuto ? 'var(--warn)' : 'var(--brand)';

              return `<div style="padding:4px; border-bottom:1px solid var(--line); display:flex; justify-content:space-between; align-items:center; last-child { border:none }">
                <div>
                  <div style="font-weight:bold; color:${codeColor};">${escapeHtml(code)} ${isChosenAuto ? '‚ú®' : ''}</div>
                  ${autoCount ? `<div style="font-size:10px; color:var(--warn); font-weight:600;">+${autoCount} students</div>` : ""}
                  <div class="mini muted">${escapeHtml(name)} ${p ? `(${p})` : ""}</div>
                  ${room ? `<div class="mini" style="font-size:9px;">üìç ${escapeHtml(room)}</div>` : ""}
                </div>
                <button class="btn secondary mini" style="padding:2px 4px; font-size:9px;" onclick="event.stopPropagation(); jumpToClass('${escapeHtml(code)}')">Show</button>
              </div>`;
            }).join("");

            html += `<td class="class-cell" ondblclick="showSlotModal('${disp}','${d}')" style="padding:0; vertical-align:top;">
              ${cellContent}
              ${more}
              <div style="padding:4px;"><button class="btn secondary mini" style="padding:2px 6px; font-size:10px;" onclick="event.stopPropagation(); showSlotModal('${disp}','${d}')">üîç View / Print</button></div>
            </td>`;
          } else {
            html += `<td ondblclick="showSlotModal('${disp}','${d}')"></td>`;
          }
        }
        html += `</tr>`;
      }
      tbody.innerHTML = html;
    }

    function showSlotModal(periodDisp, day) {
      const ttRows = state.raw.timetable || [];
      const m = state.mapping;

      // Support merged periods
      const searchPeriods = PERIOD_MAP[periodDisp] || [periodDisp];

      const matches = ttRows.filter(r =>
        searchPeriods.some(p => looseMatch(r[m.tt_period], p)) &&
        (day === 'All Days' || looseMatch(r[m.tt_day], day))
      );

      // Sort matches: Chosen first, then alphabetical by code
      matches.sort((a, b) => {
        const codeA = normId(a[m.tt_classcode]);
        const codeB = normId(b[m.tt_classcode]);
        const dayA = a[m.tt_day];
        const dayB = b[m.tt_day];
        const pA = a[m.tt_period];
        const pB = b[m.tt_period];
        const isChosenA = !!state.chosenClasses[`${codeA}|${dayA}|${pA}`];
        const isChosenB = !!state.chosenClasses[`${codeB}|${dayB}|${pB}`];

        if (isChosenA && !isChosenB) return -1;
        if (!isChosenA && isChosenB) return 1;
        return codeA.localeCompare(codeB);
      });

      const modal = document.getElementById("modalOverlay");
      const title = document.getElementById("modalTitle");
      const body = document.getElementById("modalBody");

      title.textContent = `${day} - ${periodDisp}`;
      modal.style.display = "flex";

      body.innerHTML = matches.map(match => {
        const code = normId(match[m.tt_classcode]);
        const name = m.tt_classname ? match[m.tt_classname] : "";
        const teacher = m.tt_teacher ? match[m.tt_teacher] : "";
        const dayVal = match[m.tt_day];
        const pVal = match[m.tt_period];
        const choiceInfo = state.chosenClasses[`${code}|${dayVal}|${pVal}`];
        const isChosen = !!choiceInfo;
        const isAuto = typeof choiceInfo === 'object' && choiceInfo.type === 'auto';
        const isLegacyAuto = choiceInfo === 'auto';
        const isChosenAuto = isAuto || isLegacyAuto;
        const autoCount = isAuto ? choiceInfo.count : 0;
        const room = m.tt_room ? (match[m.tt_room] || "") : (match["Room"] || "");

        return `
          <div class="card" style="margin-bottom:10px; border:1px solid var(--line);">
            <div class="bd row" style="justify-content:space-between; align-items:center; padding:8px 12px; gap:12px;">
              <div style="flex:1;">
                <div style="font-weight:bold; font-size:15px; color:${isChosenAuto ? 'var(--warn)' : 'var(--brand)'};">${escapeHtml(code)} ${isChosenAuto ? '‚ú®' : ''}</div>
                ${autoCount ? `<div style="font-size:11px; color:var(--warn); font-weight:600;">Adds +${autoCount} students to audit</div>` : ""}
                <div class="mini">${escapeHtml(name)} ${pVal ? `(${pVal})` : ""}</div>
                <div class="mini muted">${escapeHtml(teacher)} ${room ? `‚Ä¢ <b>Room ${room}</b>` : ""}</div>
              </div>
              <div class="row" style="gap:6px; align-items:center;">
                <button class="btn ${isChosen ? (isChosenAuto ? 'warn' : 'brand') : 'secondary'} mini" style="padding:4px 8px;" onclick="toggleChosen('${escapeHtml(code)}','${escapeHtml(dayVal)}','${escapeHtml(pVal)}'); showSlotModal('${periodDisp}', '${day}')">
                   ${isChosen ? (isChosenAuto ? '‚ú® Auto-Chosen' : '‚≠ê Chosen') : '‚òÜ Select for Audit'}
                </button>
                <div style="border-left:1px solid var(--line); height:30px; margin:0 4px;"></div>
                <button class="btn secondary mini" onclick="jumpToClass('${escapeHtml(code)}'); closeModal();">Audit</button>
                <button class="btn secondary mini" onclick="printClassList('${escapeHtml(code)}', '${escapeHtml(pVal)}', '${escapeHtml(dayVal)}', '${escapeHtml(teacher)}', '${escapeHtml(room)}')">üñ®Ô∏è Print</button>
              </div>
            </div>
          </div>
        `;
      }).join("");
    }

    function closeModal(id = "modalOverlay") {
      document.getElementById(id).style.display = "none";
    }

    function toggleChosen(code, day, period) {
      if (!state.chosenClasses) state.chosenClasses = {};
      const key = `${code}|${day}|${period}`;
      if (state.chosenClasses[key]) {
        delete state.chosenClasses[key];
      } else {
        state.chosenClasses[key] = 'manual';
      }
      saveLocal("chosen-toggle");
      renderTimetable();
    }

    function showStudentDetails(eqid) {
      const s = (state.merged.students || []).find(x => x.EQ_Id === eqid);
      if (!s) return;

      const modal = document.getElementById("modalOverlay");
      const title = document.getElementById("modalTitle");
      const body = document.getElementById("modalBody");

      title.textContent = `Student Details: ${s.StudentName}`;
      modal.style.display = "flex";

      const ttRows = state.raw.timetable || [];
      const m = state.mapping;
      const studentClasses = (s.Classes || []).map(c => normId(c.classCode)).filter(Boolean);

      const studentTimetable = ttRows.filter(r => {
        const code = normId(r[m.tt_classcode]);
        return studentClasses.includes(code);
      }).sort((a, b) => {
        const days = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"];
        const dDiff = days.indexOf(a[m.tt_day]) - days.indexOf(b[m.tt_day]);
        if (dDiff !== 0) return dDiff;
        return (a[m.tt_period] || "").localeCompare(b[m.tt_period] || "");
      });

      const ttHtml = studentTimetable.length ? `
        <div style="margin-top:10px; border:1px solid var(--line); border-radius:8px; overflow:hidden;">
          <table style="width:100%; font-size:11px; border-collapse:collapse;">
            <thead>
              <tr style="background:var(--card2); border-bottom:1px solid var(--line);">
                <th style="padding:6px; text-align:left;">Day</th>
                <th style="padding:6px; text-align:left;">Period</th>
                <th style="padding:6px; text-align:left;">Class</th>
                <th style="padding:6px; text-align:left;">Teacher</th>
              </tr>
            </thead>
            <tbody>
              ${studentTimetable.map(r => `
                <tr style="border-bottom:1px solid var(--line);">
                  <td style="padding:6px;">${escapeHtml(r[m.tt_day])}</td>
                  <td style="padding:6px;">${escapeHtml(r[m.tt_period])}</td>
                  <td style="padding:6px;"><b>${escapeHtml(r[m.tt_classcode])}</b></td>
                  <td style="padding:6px;">${escapeHtml(r[m.tt_teacher])}</td>
                </tr>
              `).join("")}
            </tbody>
          </table>
        </div>
      ` : '<div class="mini muted" style="padding:10px;">No timetable data found for this student.</div>';

      const studentEmail = eqid + "@eq.edu.au";
      const parentEmail = s.ParentEmail || "";
      const mailto = `mailto:${studentEmail}?bcc=${encodeURIComponent(parentEmail)}&subject=${encodeURIComponent("School Device Audit Update")}&body=${encodeURIComponent("Hi " + s.FirstName + ",\n\n regarding your school device...")}`;

      const popoutLink = s.TTPopout ? `
        <button class="btn secondary" onclick="window.open('${escapeHtml(s.TTPopout)}', '_blank')">üìÖ Weekly Timetable</button>
      ` : "";

      body.innerHTML = `
        <div style="padding:10px;">
          <div class="row" style="justify-content:space-between; align-items:flex-start; margin-bottom:15px; gap:10px;">
            <div style="flex:1;">
              <div style="font-weight:bold; font-size:18px;">${escapeHtml(s.StudentName)}</div>
              <div class="mini muted">${escapeHtml(eqid)} ‚Ä¢ Year ${escapeHtml(s.YearLevel)} ‚Ä¢ ${escapeHtml(s.RollClass)}</div>
            </div>
            <div class="row" style="gap:5px;">
              ${popoutLink}
              <button class="btn brand" onclick="window.location.href='${mailto}'">üìß Email</button>
            </div>
          </div>

          <div style="margin-bottom:15px; display:grid; grid-template-columns:1fr 1fr; gap:15px;">
            <div>
              <b>Device Info</b>
              <div class="mini" style="background:var(--card2); padding:8px; border-radius:8px; border:1px solid var(--line); margin-top:5px; height:100%;">
                <div><b>Serial:</b> ${escapeHtml(s.DeviceSerial || "None")}</div>
                <div><b>Hostname:</b> ${escapeHtml(s.DeviceHostname || "None")}</div>
                <div><b>Type:</b> ${escapeHtml(s.DeviceType || "None")}</div>
                <div style="color:var(--brand); margin-top:4px;"><b>IT Status:</b> ${escapeHtml(s.DeviceNotes || "None")}</div>
              </div>
            </div>
            <div>
              <b>Audit Notes</b>
              <div class="mini" style="background:var(--bg); padding:8px; border-radius:8px; border:1px solid var(--line); margin-top:5px; min-height:60px; max-height:100px; overflow-y:auto;">
                ${escapeHtml(s.AuditNotes || "No audit notes recorded.")}
              </div>
            </div>
          </div>

          <div>
            <b>Class Schedule</b>
            ${ttHtml}
          </div>

          <div class="row" style="justify-content:flex-end; margin-top:20px;">
            <button class="btn secondary" onclick="closeModal()">Close</button>
          </div>
        </div>
      `;
    }
    window.showStudentDetails = showStudentDetails;

    function autoFillMissingStudents() {
      const m = state.mapping;
      if (!m || !m.tt_classcode || !m.tt_period || !m.tt_day) {
        alert("Please map Timetable columns first.");
        return;
      }

      const allStudents = state.merged.students || [];
      if (!allStudents.length) {
        alert("No students imported yet.");
        return;
      }

      // Get selections from modal if open
      const selDays = Array.from(document.querySelectorAll('input[name="autoDay"]:checked')).map(i => i.value);
      const selPeriods = Array.from(document.querySelectorAll('input[name="autoPeriod"]:checked')).map(i => i.value);

      // If modal was used, update bulkFilters for persistence
      if (selDays.length > 0 && selPeriods.length > 0) {
        if (!state.bulkFilters) state.bulkFilters = {};
        state.bulkFilters.days = selDays;
        state.bulkFilters.periods = selPeriods;
        closeModal();
      }

      // 1. Identify currently covered student codes (via any class match)
      const chosenKeys = Object.keys(state.chosenClasses || {});
      const chosenCodes = new Set(chosenKeys.map(k => k.split("|")[0]));

      let uncovered = allStudents.filter(s =>
        !s.isArchived && // Don't try to cover archived students
        !(s.Classes || []).some(c => c.classCode && chosenCodes.has(normId(c.classCode)))
      );

      if (uncovered.length === 0) {
        alert("All active students are already covered by the audit schedule!");
        return;
      }

      // 2. Prepare candidate slots from timetable, filtered by bulkFilters (days/periods)
      const f = state.bulkFilters || { days: [], periods: [] };
      const ttRows = state.raw.timetable || [];
      const slots = ttRows.map(r => ({
        code: normId(r[m.tt_classcode]),
        day: r[m.tt_day],
        period: r[m.tt_period],
        key: `${normId(r[m.tt_classcode])}|${r[m.tt_day]}|${r[m.tt_period]}`
      })).filter(s => {
        if (!s.code || !s.day || !s.period) return false;

        // Filter by Day
        const dayMatch = (f.days.length === 0) || f.days.some(d => looseMatch(s.day, d));
        if (!dayMatch) return false;

        // Filter by Period
        const periodMatch = (f.periods.length === 0) || f.periods.some(p => looseMatch(s.period, p));
        return periodMatch;
      });


      if (slots.length === 0) {
        alert("No timetable slots match your current day/period filters. Please check your Bulk Select settings.");
        return;
      }

      // Create a map: classCode -> set of EQ_Ids who belong to it
      // We can get this from allStudents.Classes
      const studentsByClassCode = new Map();
      allStudents.forEach(s => {
        (s.Classes || []).forEach(c => {
          const code = normId(c.classCode);
          if (!code) return;
          if (!studentsByClassCode.has(code)) studentsByClassCode.set(code, new Set());
          studentsByClassCode.get(code).add(s.EQ_Id);
        });
      });

      let addedCount = 0;
      let uncoveredSet = new Set(uncovered.map(s => s.EQ_Id));

      // Greedy loop: pick slot that covers most uncovered
      while (uncoveredSet.size > 0) {
        let bestSlot = null;
        let bestCount = 0;

        for (const slot of slots) {
          if (state.chosenClasses[slot.key]) continue; // Already picked

          const studentsInClass = studentsByClassCode.get(slot.code);
          if (!studentsInClass) continue;

          let count = 0;
          for (const sid of studentsInClass) {
            if (uncoveredSet.has(sid)) count++;
          }

          if (count > bestCount) {
            bestCount = count;
            bestSlot = slot;
          }
        }

        if (!bestSlot || bestCount === 0) break;

        // Pick it!
        state.chosenClasses[bestSlot.key] = { type: 'auto', count: bestCount };
        addedCount++;

        // Remove covered students from uncoveredSet
        const newlyCovered = studentsByClassCode.get(bestSlot.code);
        for (const sid of newlyCovered) {
          uncoveredSet.delete(sid);
        }
      }

      saveLocal("auto-fill");
      renderTimetable();
      alert(`Auto-filled ${addedCount} extra classes. ${uncoveredSet.size} students still remain uncovered (likely have no timetable matching these slots).`);
    }

    function showAutoFillModal() {
      const modal = document.getElementById("modalOverlay");
      const title = document.getElementById("modalTitle");
      const body = document.getElementById("modalBody");

      title.textContent = "üéØ Auto-Fill Audit Schedule";
      modal.style.display = "flex";

      const f = state.bulkFilters || { days: [], periods: [] };

      body.innerHTML = `
      <div style="padding:10px;">
        <p class="mini muted">Pick the days and periods that the audit team is actually available to go to classrooms. The system will then pick the classes that cover the most missing students during those times.</p>
        
        <div style="margin-bottom:15px;">
          <label style="display:block; font-weight:bold; margin-bottom:5px;">Days Available</label>
          <div style="display:grid; grid-template-columns: repeat(3, 1fr); gap:8px;">
            ${DAYS.map(d => `
              <label style="display:flex; align-items:center; gap:5px; cursor:pointer; font-size:12px;">
                <input type="checkbox" name="autoDay" value="${d}" ${f.days.includes(d) ? 'checked' : ''}> ${d.slice(0, 3)}
              </label>
            `).join("")}
          </div>
        </div>

        <div style="margin-bottom:15px;">
          <label style="display:block; font-weight:bold; margin-bottom:5px;">Periods Available</label>
          <div style="display:grid; grid-template-columns: repeat(4, 1fr); gap:8px;">
            ${["HC", "1", "2", "3", "4", "5", "6", "7", "8"].map(p => `
              <label style="display:flex; align-items:center; gap:5px; cursor:pointer; font-size:12px;">
                <input type="checkbox" name="autoPeriod" value="${p}" ${f.periods.includes(p) ? 'checked' : ''}> ${p}
              </label>
            `).join("")}
          </div>
        </div>

        <div style="background:rgba(16, 185, 129, 0.05); padding:10px; border:1px solid var(--good); border-radius:8px; font-size:11px; color:var(--text); margin-top:10px;">
          <b>Greedy Algorithm:</b> This will analyze all students NOT currently in your audit list and find the best classes to add to cover them.
        </div>

        <div style="display:flex; justify-content:flex-end; gap:10px; margin-top:20px;">
          <button class="btn secondary" onclick="closeModal()">Cancel</button>
          <button class="btn good" onclick="autoFillMissingStudents()">üéØ Run Auto-Fill</button>
        </div>
      </div>
    `;
    }
    window.showAutoFillModal = showAutoFillModal;


    function showBulkSelectModal() {
      const modal = document.getElementById("modalOverlay");
      const title = document.getElementById("modalTitle");
      const body = document.getElementById("modalBody");

      title.textContent = "Bulk Select Classes for Audit";
      modal.style.display = "flex";

      const f = state.bulkFilters;

      body.innerHTML = `
      <div style="padding:10px;">
        <div style="margin-bottom:15px;">
          <label style="display:block; font-weight:bold; margin-bottom:5px;">Subject Prefix (e.g. ENG)</label>
          <input type="text" id="bulkSubject" placeholder="ENG" style="width:100%; padding:8px; border:1px solid var(--line); border-radius:4px;" value="${escapeHtml(f.prefix)}">
          <small class="muted">Finds classes starting with this text. Clear to ignore.</small>
        </div>

        <div style="margin-bottom:15px;">
          <label style="display:block; font-weight:bold; margin-bottom:5px;">Days of Week</label>
          <div style="display:grid; grid-template-columns: repeat(3, 1fr); gap:8px;">
            ${DAYS.map(d => `
              <label style="display:flex; align-items:center; gap:5px; cursor:pointer; font-size:12px;">
                <input type="checkbox" name="bulkDay" value="${d}" ${f.days.includes(d) ? 'checked' : ''}> ${d.slice(0, 3)}
              </label>
            `).join("")}
          </div>
        </div>

        <div style="margin-bottom:15px;">
          <label style="display:block; font-weight:bold; margin-bottom:5px;">Periods / Lessons</label>
          <div style="display:grid; grid-template-columns: repeat(4, 1fr); gap:8px;">
            ${["HC", "1", "2", "3", "4", "5", "6", "7", "8"].map(p => `
              <label style="display:flex; align-items:center; gap:5px; cursor:pointer; font-size:12px;">
                <input type="checkbox" name="bulkPeriod" value="${p}" ${f.periods.includes(p) ? 'checked' : ''}> ${p}
              </label>
            `).join("")}
          </div>
        </div>

        <div style="background:var(--card2); padding:10px; border-radius:4px; font-size:11px; color:var(--muted); margin-top:10px;">
          <b>Note:</b> This will add all matching unique class codes to your "Chosen for Audit" list. It will NOT remove existing selections.
        </div>

        <div style="display:flex; justify-content:flex-end; gap:10px; margin-top:20px;">
          <button class="btn secondary" onclick="closeModal()">Cancel</button>
          <button class="btn brand" onclick="applyBulkSelection()">Apply Selection</button>
        </div>
      </div>
    `;
    }

    function applyBulkSelection() {
      const prefix = document.getElementById("bulkSubject").value.trim().toUpperCase();
      const selDays = Array.from(document.querySelectorAll('input[name="bulkDay"]:checked')).map(i => i.value);
      const selPeriods = Array.from(document.querySelectorAll('input[name="bulkPeriod"]:checked')).map(i => i.value);

      if (selDays.length === 0 || selPeriods.length === 0) {
        alert("Please select at least one day and one period.");
        return;
      }

      const ttRows = state.raw.timetable || [];
      const m = state.mapping;
      if (!m) {
        alert("Please map your timetable columns first.");
        return;
      }

      // Save filters for next time
      state.bulkFilters = { prefix, days: selDays, periods: selPeriods };

      // Find classes matching prefix
      const allUniqueMatchingClasses = [...new Set(ttRows.filter(r => {
        const code = normId(r[m.tt_classcode]);
        return code && (!prefix || code.toUpperCase().startsWith(prefix));
      }).map(r => normId(r[m.tt_classcode])))];

      if (allUniqueMatchingClasses.length === 0) {
        alert(`No classes found starting with "${prefix}".`);
        return;
      }

      let countAdded = 0;
      const missedClasses = [];
      const addedCodes = [];

      allUniqueMatchingClasses.forEach(code => {
        // Find ALL instances of this class in the timetable
        const instances = ttRows.filter(r => normId(r[m.tt_classcode]) === code);

        // Find the first instance that matches the day/period selection
        const matchingInstance = instances.find(r => {
          const day = r[m.tt_day];
          const period = r[m.tt_period];
          const matchDay = selDays.some(d => looseMatch(day, d));
          const matchPeriod = selPeriods.some(p => looseMatch(period, p));
          return matchDay && matchPeriod;
        });

        if (matchingInstance) {
          const d = matchingInstance[m.tt_day];
          const p = matchingInstance[m.tt_period];
          const key = `${code}|${d}|${p}`;
          if (!state.chosenClasses[key]) {
            state.chosenClasses[key] = 'manual';
            countAdded++;
            addedCodes.push(code);
          }
        } else {
          // This class exists, but not on any of the selected days/periods
          missedClasses.push(code);
        }
      });

      saveLocal("bulk-selection");
      renderTimetable();
      closeModal();

      let msg = `Successfully added ${countAdded} classes to audit.\n`;
      if (missedClasses.length > 0) {
        msg += `\n‚ö†Ô∏è Missed ${missedClasses.length} classes (they don't occur on your selected days/periods):\n${missedClasses.slice(0, 5).join(", ")}${missedClasses.length > 5 ? '...' : ''}`;
      }
      alert(msg);
    }

    async function selectExternalDbFile() {
      try {
        const [handle] = await window.showOpenFilePicker({
          types: [{
            description: 'Audit JSON Database',
            accept: { 'application/json': ['.json'] },
          }],
          multiple: false
        });

        if (!handle) return;

        state._dbFileHandle = handle;
        // Verify we can read it
        const file = await handle.getFile();
        const text = await file.text();
        const payload = JSON.parse(text);

        if (payload?.state) {
          if (confirm("Found valid database in file. Load it now? (Will overwrite current local state)")) {
            Object.assign(state, payload.state);
            state._dbFileHandle = handle; // Restore handle after state overwrite
            saveLocal("file-link");
            location.reload();
          }
        } else {
          if (confirm("File is empty or invalid. Use this file for future auto-saves?")) {
            saveLocal("file-link-new");
          }
        }
      } catch (e) {
        console.error("File selection failed", e);
      }
    }
    window.selectExternalDbFile = selectExternalDbFile;

    function showSection(id) {
      document.querySelectorAll('main').forEach(m => m.style.display = 'none');
      const target = document.getElementById('section-' + id);
      if (target) target.style.display = 'block';

      document.querySelectorAll('.tab.nav').forEach(b => {
        b.classList.toggle('active', b.getAttribute('onclick')?.includes(id));
      });

      if (id === 'timetable') renderTimetable();
      if (id === 'equity') renderEquityTracking();
      if (id === 'dashboard') render();
      if (id === 'config' && typeof updateSourceDirUI === 'function') updateSourceDirUI();

      saveLocal("tab-switch");
    }
    window.showSection = showSection;


    function jumpToClass(code) {
      els.filterClass.value = code; // Note: simplified, might need exact match logic
      showSection('dashboard');
      render();
    }

    async function saveLocal(reason = "auto") {
      const dbKey = LS_KEY_BASE + "." + state.dbSuffix;
      localStorage.setItem("deviceAuditApp.currentDbSuffix", state.dbSuffix);

      const payload = {
        version: 1,
        savedAt: nowISO(),
        reason,
        state
      };

      let idbSuccess = false;
      try {
        await dbSet(dbKey, payload);
        idbSuccess = true;
      } catch (e) { console.error("IDB save failed", e); }

      // Save to Master DB (CSV)
      if (state._masterDbHandle) {
        saveToMasterDB();
      }

      // Save to Settings (JSON)
      if (state._settingsFileHandle) {
        saveSettings();
      }

      let extSuccess = false;
      if (state._dbFileHandle) {
        try {
          if (await state._dbFileHandle.queryPermission({ mode: 'readwrite' }) === 'granted') {
            const writable = await state._dbFileHandle.createWritable();
            await writable.write(JSON.stringify(payload, null, 2));
            await writable.close();
            extSuccess = true;
          }
        } catch (e) { }
      }

      const s = document.getElementById("saveStatus");
      if (s) {
        if (idbSuccess || extSuccess) {
          s.textContent = "Saved " + new Date().toLocaleTimeString() + (extSuccess ? " (+Files)" : "");
          s.style.color = "var(--good)";
        } else {
          s.textContent = "SAVE FAILED";
          s.style.color = "var(--bad)";
        }
        setTimeout(() => { s.textContent = "Auto-save: ON"; s.style.color = ""; }, 3000);
      }
    }

    async function loadLocal() {
      const dbKey = LS_KEY_BASE + "." + state.dbSuffix;
      let payload = await dbGet(dbKey);

      if (!payload) {
        const raw = localStorage.getItem(dbKey);
        if (raw) {
          try {
            payload = JSON.parse(raw);
            console.log("Migrating LS to IDB...");
            await dbSet(dbKey, payload);
          } catch (e) { }
        }
      }

      if (!payload) {
        render();
        return;
      }

      try {
        if (payload?.state) {
          const migratedState = migrateState(payload.state);
          Object.assign(state, migratedState);
          state.dbSuffix = CURRENT_DB_SUFFIX;

          if (!state.selectedStudents) state.selectedStudents = {};
          if (!state._auditHistory) state._auditHistory = {};
          if (!state._handles) state._handles = {};

          if (state.mapping) renderMappingUI();
          if (state.raw.student?.length) doMerge();
          updateMetaUI();

          // 1. Restore Project Folder (this now handles everything)
          loadHandle("projectFolderHandle").then(async ph => {
            if (ph) {
              state._projectFolderHandle = ph;
              state._sourceDirHandle = ph; // Use project folder as source dir too
              const hasPerm = await ph.queryPermission({ mode: 'readwrite' }) === 'granted';
              if (hasPerm) {
                await syncProjectFolder(ph);
              } else {
                updatePersistenceUI();
                const warning = document.getElementById("connectionWarning");
                if (warning) warning.style.display = "flex";
              }
            } else {
              updatePersistenceUI();
            }
          });

          refreshFilters();
          render();

          setTag(els.saveTag, "Local save: loaded (" + state.dbSuffix + ")", "good");
          setTimeout(() => setTag(els.saveTag, "Local save: idle"), 1500);
        }
      } catch (e) {
        console.warn("Load failed", e);
        render();
      }
    }

    function switchDatabase(newSuffix) {
      if (!newSuffix) return;
      state.dbSuffix = newSuffix;
      localStorage.setItem("deviceAuditApp.currentDbSuffix", newSuffix);
      location.reload();
    }

    function clearAll() {
      const dbKey = LS_KEY_BASE + "." + state.dbSuffix;
      dbDel(dbKey).then(() => location.reload());
    }

    /** ========= Backup & File System API ========= **/
    const IDB_CONFIG = { name: "AuditBackupDB", store: "handles", key: "folderHandle" };

    async function getIDBStore() {
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(IDB_CONFIG.name, 1);
        req.onupgradeneeded = () => req.result.createObjectStore(IDB_CONFIG.store);
        req.onsuccess = () => resolve(req.result.transaction(IDB_CONFIG.store, "readwrite").objectStore(IDB_CONFIG.store));
        req.onerror = () => reject(req.error);
      });
    }

    async function saveHandle(handle, key = IDB_CONFIG.key) {
      const store = await getIDBStore();
      store.put(handle, key);
    }
    window.saveHandle = saveHandle;

    async function loadHandle(key = IDB_CONFIG.key) {
      const store = await getIDBStore();
      return new Promise((resolve) => {
        const req = store.get(key);
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => resolve(null);
      });
    }
    window.loadHandle = loadHandle;



    async function setSourceDirectory() {
      try {
        const handle = await window.showDirectoryPicker({ id: 'source-dir', mode: 'read' });
        await saveHandle(handle, "sourceDirHandle");
        state._sourceDirHandle = handle;
        updateSourceDirUI();
        saveLocal("source-dir-set");
        alert("Source directory set to: " + handle.name);
      } catch (e) {
        if (e.name !== 'AbortError') console.error("Source directory selection failed", e);
      }
    }
    window.setSourceDirectory = setSourceDirectory;

    async function selectBackupFolder() {
      try {
        const handle = await window.showDirectoryPicker({ id: 'backup-dir', mode: 'readwrite' });
        await saveHandle(handle, "folderHandle");
        state.backupSettings.folderName = handle.name;
        const label = document.getElementById("backupFolderName");
        if (label) label.textContent = handle.name;

        // Setup master JSON in this folder
        await setupMasterJson(handle);

        saveLocal("backup-folder-set");
        alert("Backup folder set to: " + handle.name + "\n'master_db.json' will be maintained here for auto-sync.");
      } catch (e) {
        if (e.name !== 'AbortError') console.error("Folder selection failed", e);
      }
    }
    window.selectBackupFolder = selectBackupFolder;

    async function setupMasterJson(folderHandle) {
      try {
        if (await folderHandle.queryPermission({ mode: 'readwrite' }) !== 'granted') {
          // Silent failure on startup, user will be prompted if they try to save
          if (folderHandle === state._dbFileHandle?.parent) return;
          // Note: we can't requestPermission silently, so we wait or show a badge
          document.getElementById("fileSyncStatus").textContent = "External Sync: Needs Permission üîë";
          return;
        }

        let targetDir = folderHandle;
        try {
          targetDir = await folderHandle.getDirectoryHandle("Backup", { create: true });
        } catch (e) { }

        const fileHandle = await targetDir.getFileHandle("master_db.json", { create: true });
        state._dbFileHandle = fileHandle;

        // Now sync from it
        await syncExternalDb(true); // silent sync
      } catch (e) {
        console.error("Master JSON setup failed", e);
      }
    }

    async function syncExternalDb(silent = false) {
      if (!state._dbFileHandle) return;
      try {
        // Query permission
        if (await state._dbFileHandle.queryPermission({ mode: 'readwrite' }) !== 'granted') {
          if (silent) {
            console.log("External Sync: Permission needed. Skipping auto-load.");
            document.getElementById("fileSyncStatus").textContent = "External Sync: Needs Permission üîë";
            return;
          }
          if (await state._dbFileHandle.requestPermission({ mode: 'readwrite' }) !== 'granted') return;
        }

        const file = await state._dbFileHandle.getFile();
        const text = await file.text();
        if (!text.trim()) {
          console.log("External Sync: File is empty. Will write to it on next save.");
          document.getElementById("fileSyncStatus").textContent = "External Sync: Linked (Empty) ‚úÖ";
          return;
        }

        const payload = JSON.parse(text);
        if (payload?.state) {
          const migratedState = migrateState(payload.state);
          // Only merge if the external file is newer than our current state or if we have no data
          const fileDate = payload.savedAt ? new Date(payload.savedAt) : new Date(0);
          const localDate = state.lastMergedAt ? new Date(state.lastMergedAt) : new Date(0);

          if (fileDate > localDate || !state.merged.students.length) {
            console.log("External Sync: Loading newer data from file...");
            Object.assign(state, migratedState);
            state.dbSuffix = CURRENT_DB_SUFFIX;
            if (state.mapping) renderMappingUI();
            updateMetaUI();
            refreshFilters();
            render();
            if (!silent) alert("Successfully synced with Master JSON in backup folder.");
          }
          document.getElementById("fileSyncStatus").textContent = "External Sync: Master Connected ‚úÖ";
        }
      } catch (e) {
        console.error("External Sync failed", e);
        document.getElementById("fileSyncStatus").textContent = "External Sync: Error ‚ùå";
        if (!silent) alert("Failed to sync with Master JSON: " + e.message);
      }
    }
    window.syncExternalDb = syncExternalDb;

    async function selectExternalDbFile() {
      alert("This has been replaced by the 'Backup Folder' sync. Specify a backup folder to maintain a master JSON file.");
    }
    window.selectExternalDbFile = selectExternalDbFile;

    async function linkMasterDbFile() {
      alert("This has been replaced by the 'Project Folder' feature. Please use 'Set Project Folder' to manage your MasterDB.csv.");
    }
    window.linkMasterDbFile = linkMasterDbFile;

    async function linkSettingsFile() {
      alert("This has been replaced by the 'Project Folder' feature. Please use 'Set Project Folder' to manage your Setting.json.");
    }
    window.linkSettingsFile = linkSettingsFile;

    async function updatePersistenceUI() {
      const warning = document.getElementById("connectionWarning");
      const status = document.getElementById("projectFolderStatus");
      const reconnectBtn = document.getElementById("pjReconnectBtn");

      if (state._projectFolderHandle) {
        const hasPerm = await state._projectFolderHandle.queryPermission({ mode: 'readwrite' }) === 'granted';
        if (status) {
          status.textContent = "Linked to: " + state._projectFolderHandle.name + (hasPerm ? " ‚úÖ" : " (Permission needed)");
          status.className = "mini " + (hasPerm ? "good" : "warn");
        }
        if (warning) warning.style.display = hasPerm ? "none" : "flex";
        if (reconnectBtn) reconnectBtn.style.display = hasPerm ? "none" : "inline-block";
      } else {
        if (status) {
          status.textContent = "No folder connected. Changes will only save to your browser cache.";
          status.className = "mini muted";
        }
        if (warning) warning.style.display = "none";
        if (reconnectBtn) reconnectBtn.style.display = "none";
      }
    }

    async function saveToMasterDB() {
      if (!state._masterDbHandle) return;
      try {
        const students = state.merged.students || [];
        if (!students.length) return;

        const cols = [
          "EQ_Id", "FirstName", "LastName", "StudentName", "YearLevel", "RollClass",
          "PrimaryClass", "DeviceSerial", "DeviceType", "DeviceHostname", "DeviceUsername",
          "DeviceNotes", "AuditConnected", "AuditNeedsConnection", "AuditAtHome",
          "AuditNeedsEquity", "AuditNotes", "isArchived", "ParentEmail", "ReturnDate", "Classes"
        ];

        const rows = students.map(s => {
          const r = {};
          cols.forEach(c => {
            let val = s[c];
            if (c === "Classes") val = (s.Classes || []).map(cl => cl.classCode).join(" | ");
            r[c] = val;
          });
          return r;
        });

        const csv = toCsv(rows, cols);
        const writable = await state._masterDbHandle.createWritable();
        await writable.write(csv);
        await writable.close();
        console.log("MasterDB.csv updated.");
      } catch (e) { console.error("Save to MasterDB failed", e); }
    }

    async function loadFromMasterDB() {
      if (!state._masterDbHandle) return;
      try {
        const file = await state._masterDbHandle.getFile();
        const text = await file.text();
        if (!text.trim()) return;

        // Use SheetJS for more robust parsing if available, else simple split
        let data = [];
        if (typeof XLSX !== 'undefined') {
          const workbook = XLSX.read(text, { type: 'string' });
          const sheet = workbook.Sheets[workbook.SheetNames[0]];
          data = XLSX.utils.sheet_to_json(sheet, { defval: "" });
        } else {
          const lines = text.split("\n").filter(l => l.trim());
          if (lines.length < 2) return;
          const headers = lines[0].split(",");
          data = lines.slice(1).map(line => {
            const vals = line.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
            const obj = {};
            headers.forEach((h, i) => {
              let v = (vals[i] || "").trim();
              if (v.startsWith('"') && v.endsWith('"')) v = v.slice(1, -1).replaceAll('""', '"');
              obj[h.trim()] = v;
            });
            return obj;
          });
        }

        state.merged.students = data.map(d => ({
          ...d,
          AuditConnected: d.AuditConnected === "true" || d.AuditConnected === true,
          AuditNeedsConnection: d.AuditNeedsConnection === "true" || d.AuditNeedsConnection === true,
          AuditAtHome: d.AuditAtHome === "true" || d.AuditAtHome === true,
          AuditNeedsEquity: d.AuditNeedsEquity === "true" || d.AuditNeedsEquity === true,
          isArchived: d.isArchived === "true" || d.isArchived === true,
          Classes: d.Classes ? d.Classes.split(" | ").map(c => ({ classCode: c.trim() })) : []
        }));

        refreshFilters();
        render();
        console.log("Data loaded from MasterDB.csv");
      } catch (e) { console.error("Load from MasterDB failed", e); }
    }

    async function saveSettings() {
      if (!state._settingsFileHandle) return;
      try {
        if (await state._settingsFileHandle.queryPermission({ mode: 'readwrite' }) !== 'granted') return;

        const settings = {
          prefixes: state.prefixes,
          mapping: state.mapping,
          bulkFilters: state.bulkFilters,
          chosenClasses: state.chosenClasses
        };
        const writable = await state._settingsFileHandle.createWritable();
        await writable.write(JSON.stringify(settings, null, 2));
        await writable.close();
        console.log("Setting.json updated");
      } catch (e) { console.error("Save settings failed", e); }
    }

    async function loadSettings() {
      if (!state._settingsFileHandle) return;
      try {
        const file = await state._settingsFileHandle.getFile();
        const text = await file.text();
        if (!text.trim()) return;
        const settings = JSON.parse(text);
        Object.assign(state, settings);
        if (state.mapping) renderMappingUI();
        updateSourceDirUI();
        refreshFilters();
        render();
        console.log("Settings loaded from Setting.json");
      } catch (e) { console.error("Load settings failed", e); }
    }

    async function autoBackupMasterDB() {
      if (!state._masterDbHandle) return;

      const folderHandle = await loadHandle("folderHandle");
      if (!folderHandle) return;

      try {
        if (await folderHandle.queryPermission({ mode: 'readwrite' }) !== 'granted') {
          // If not granted, we can't do auto-backup silently on start unless they previously granted it for the session
          // But we can try to copy.
          return;
        }

        let backupFolder;
        try {
          backupFolder = await folderHandle.getDirectoryHandle("Backup", { create: true });
        } catch (e) { backupFolder = folderHandle; }

        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 16);
        const backupName = `MasterDB_backup_${timestamp}.csv`;

        const file = await state._masterDbHandle.getFile();
        const backupFileHandle = await backupFolder.getFileHandle(backupName, { create: true });
        const writable = await backupFileHandle.createWritable();
        await writable.write(await file.arrayBuffer());
        await writable.close();

        console.log("Auto-backup created: " + backupName);
      } catch (e) { console.error("Auto-backup failed", e); }
    }

    function updateSourceDirUI() {
      const el = document.getElementById("sourceDirName");
      const btn = document.getElementById("btnSmartScan");
      if (state._sourceDirHandle) {
        el.textContent = state._sourceDirHandle.name;
        el.className = "mini good";
        if (btn) btn.style.display = "inline-flex";
      } else {
        el.textContent = "Not set";
        el.className = "mini muted";
        if (btn) btn.style.display = "none";
      }

      // Also update prefix inputs in UI
      if (state.prefixes) {
        ['student', 'sclass', 'timetable', 'device'].forEach(t => {
          const inp = document.getElementById("pre_" + t);
          if (inp) inp.value = state.prefixes[t] || "";
        });
      }
    }

    async function scanAndImport(silent = false) {
      const handle = state._sourceDirHandle;
      if (!handle) {
        if (!silent) alert("Please set a source directory first.");
        return;
      }


      try {
        if (await handle.queryPermission({ mode: 'read' }) !== 'granted') {
          if (await handle.requestPermission({ mode: 'read' }) !== 'granted') return;
        }

        const files = [];
        for await (const entry of handle.values()) {
          if (entry.kind === 'file') {
            const file = await entry.getFile();
            files.push(file);
          }
        }

        const types = ['student', 'sclass', 'timetable', 'device'];
        let matchedSomething = false;

        for (const type of types) {
          const prefix = (state.prefixes[type] || "").toLowerCase().trim();
          if (!prefix) continue;

          // Find matches
          const matches = files.filter(f => f.name.toLowerCase().startsWith(prefix));
          if (matches.length === 0) continue;

          // Pick latest by Last Modified
          matches.sort((a, b) => b.lastModified - a.lastModified);
          const latest = matches[0];

          console.log(`Smart Import: Picked latest for ${type}: ${latest.name}`);
          await processFile(latest, type);
          matchedSomething = true;
        }

        if (matchedSomething) {
          console.log("Smart Import: Syncing with database...");
          await doMerge();
          if (!silent) alert("Smart scan complete. Files matched, imported, and merged automatically.");
          else console.log("Smart Import: Silent scan and merge complete.");
        } else {
          if (!silent) alert("No files matched the specified prefixes in the source directory.");
        }
      } catch (e) {
        if (!silent) alert("Scan failed: " + e.message);
        else console.error("Auto-scan failed", e);
      }

    }
    async function checkAndAutoScan() {
      if (!state._sourceDirHandle) return;
      try {
        if (await state._sourceDirHandle.queryPermission({ mode: 'read' }) === 'granted') {
          console.log("Auto-scan: Permission already granted. Scanning...");
          await scanAndImport(true); // silent scan
        } else {
          console.log("Auto-scan: Permission needed. User must trigger manual scan.");
        }
      } catch (e) {
        console.warn("Auto-scan check failed", e);
      }
    }
    window.checkAndAutoScan = checkAndAutoScan;



    function toggleAutoBackup(val) {
      state.backupSettings.autoOnOpen = val;
      localStorage.setItem("deviceAuditApp.autoBackup", val);
      saveLocal("auto-backup-toggle");
    }

    async function autoBackupFlow() {
      const handle = await loadHandle();
      if (!handle) return;

      try {
        if (await handle.queryPermission({ mode: 'readwrite' }) !== 'granted') {
          if (window.event && window.event.type === 'click') {
            if (await handle.requestPermission({ mode: 'readwrite' }) !== 'granted') return;
          } else return;
        }

        let backupFolder;
        try {
          backupFolder = await handle.getDirectoryHandle("Backup", { create: true });
        } catch (e) {
          backupFolder = handle;
        }

        const filename = `audit_backup_${state.dbSuffix}_${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
        const fileHandle = await backupFolder.getFileHandle(filename, { create: true });
        const writable = await fileHandle.createWritable();

        await writable.write(JSON.stringify({ state, exportedAt: nowISO() }, null, 2));
        await writable.close();

        setTag(els.saveTag, "Backup saved ‚úÖ", "good");
        setTimeout(() => setTag(els.saveTag, "Local save: idle"), 2000);
      } catch (e) {
        console.error("Backup failed", e);
      }
    }

    /** ========= Email Parents ========= **/
    function emailParentsByStatus(status) {
      const students = state.merged.students || [];
      const m = state.mapping;
      let targetList = [];
      let statusDesc = "";

      if (status === 'selected') {
        targetList = students.filter(s => state.selectedStudents[s.EQ_Id]);
        statusDesc = "Selected Students";
      } else if (status === 'missing') {
        targetList = students.filter(s => !(s.DeviceSerial || s.DeviceHostname || s.DeviceType || (s.DeviceMatches || []).length));
        statusDesc = "Missing Device";
      } else if (status === 'notConnected') {
        targetList = students.filter(s => s.AuditConnected === false);
        statusDesc = "No Network Connection";
      } else if (status === 'needsEquity') {
        targetList = students.filter(s => s.AuditNeedsEquity);
        statusDesc = "Requires Equity Device";
      } else if (status === 'atHome') {
        targetList = students.filter(s => s.AuditAtHome);
        statusDesc = "Device at Home";
      }

      // Filter by Contactable status (if mapped)
      if (m.si_contactable) {
        const initialCount = targetList.length;
        targetList = targetList.filter(s => {
          const raw = (s.Contactable ?? "").toString().trim().toUpperCase();
          return raw !== "N";
        });
        const removedCount = initialCount - targetList.length;
        if (removedCount > 0) {
          console.log(`Filtered out ${removedCount} students marked as non-contactable.`);
        }
      }

      const emails = [...new Set(targetList.map(s => (s.ParentEmail || "").trim()).filter(Boolean))];
      if (!emails.length) {
        alert(`No contactable parent emails found for the current criteria. Ensure you have mapped 'Parent Email' and 'Contactable' correctly.`);
        return;
      }

      const bcc = emails.join(";");
      const subject = encodeURIComponent(`School Device Audit Update - ${statusDesc}`);
      const body = encodeURIComponent(`Dear Parent/Guardian,\n\nThis is a friendly reminder regarding the recent school device audit. Our records indicate an update is required for your child's device status: ${statusDesc}.\n\nPlease ensure this is addressed. Contact the school IT department if you have any questions.\n\nThank you.`);

      window.location.href = `mailto:?bcc=${bcc}&subject=${subject}&body=${body}`;
    }

    const EQUITY_STAGES = [
      { id: 0, label: "0- Not Started" },
      { id: 1, label: "1- Given form" },
      { id: 2, label: "2- Getting device ready" },
      { id: 3, label: "3- Device ready for pickup" },
      { id: 4, label: "4- Picked up" }
    ];

    function renderEquityTracking() {
      const students = state.merged.students || [];
      const equityStudents = students.filter(s => s.AuditNeedsEquity);
      const tbody = document.getElementById("equityTrackingBody");

      if (!equityStudents.length) {
        tbody.innerHTML = `<tr><td colspan="5" class="muted" style="padding:40px; text-align:center;">No students marked as "Needs Equity". Go to Dashboard or Audit list to mark them.</td></tr>`;
        return;
      }

      equityStudents.sort((a, b) => a.StudentName.localeCompare(b.StudentName));

      tbody.innerHTML = equityStudents.map(s => {
        const eqid = s.EQ_Id;
        const status = state._equityStatus[eqid] || 0;
        const history = state._auditHistory[eqid] || [];
        const parentEmail = s.ParentEmail || "(No email)";

        const options = EQUITY_STAGES.map(stage =>
          `<option value="${stage.id}" ${status == stage.id ? 'selected' : ''}>${stage.label}</option>`
        ).join("");

        const historyHtml = history.map(h => `
          <div class="mini" style="margin-bottom:4px; padding-bottom:4px; border-bottom:1px solid var(--line);">
            <b style="font-size:10px;">${new Date(h.date).toLocaleDateString()} ${new Date(h.date).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}:</b>
            <div>${escapeHtml(h.text)}</div>
          </div>
        `).join("");

        return `
          <tr>
            <td>
              <div style="font-weight:bold;">${escapeHtml(s.StudentName)}</div>
              <div class="mini muted">${escapeHtml(eqid)} ‚Ä¢ Year ${escapeHtml(s.YearLevel)}</div>
            </td>
            <td>
              <select onchange="window.__setEquityStatus('${escapeHtml(eqid)}', this.value)" style="padding:4px; font-size:12px; width:100%;">
                ${options}
              </select>
              <div style="margin-top:10px;">
                <input type="text" placeholder="Add tracking note..." 
                       id="note-in-${escapeHtml(eqid)}" 
                       style="width:100%; font-size:11px; padding:4px;"
                       onkeyup="if(event.key==='Enter') { addAuditNote('${escapeHtml(eqid)}', this.value); this.value=''; }">
              </div>
            </td>
            <td>
              <div class="mini">${escapeHtml(parentEmail)}</div>
              <button class="btn secondary mini" style="padding:2px 6px; margin-top:4px;" onclick="window.location.href='mailto:${escapeHtml(parentEmail)}?subject=Equity Device Update&body=Hi ${escapeHtml(s.FirstName)},'">üìß Email</button>
            </td>
            <td>
              <input type="date" value="${s.ReturnDate || ''}" 
                style="font-size:12px; padding:4px; width:100%;"
                onchange="window.__setReturnDate('${escapeHtml(eqid)}', this.value)">
              ${s.ReturnDate && new Date(s.ReturnDate) < new Date() && status !== 4 ? '<div class="mini bad" style="font-weight:bold; margin-top:2px;">‚ö†Ô∏è OVERDUE</div>' : ''}
            </td>
            <td>
              <div style="max-height:150px; overflow-y:auto; padding-right:5px;">
                ${historyHtml || '<div class="mini muted">No history recorded</div>'}
              </div>
            </td>
          </tr>
        `;
      }).join("");
    }

    function __setEquityStatus(eqid, status) {
      const oldStatus = state._equityStatus[eqid] || 0;
      state._equityStatus[eqid] = parseInt(status);

      const newLabel = EQUITY_STAGES.find(st => st.id == status)?.label || status;
      addAuditNote(eqid, `Status changed to: ${newLabel}`);

      saveLocal("equity-status-update");
      setTag(els.saveTag, "Status Updated ‚úÖ", "good");
      setTimeout(() => setTag(els.saveTag, "Local save: idle"), 1500);
    }
    function __setReturnDate(eqid, date) {
      const row = (state.merged.students || []).find(s => s.EQ_Id === eqid);
      if (row) {
        row.ReturnDate = date;
        addAuditNote(eqid, `Return date set to: ${date || 'None'}`);
        saveLocal("return-date-update");
        renderEquityTracking();
        render(); // Update KPIs
      }
    }
    window.__setReturnDate = __setReturnDate;

    /** ========= Import helpers ========= **/

    async function readSheet(file) { // Renamed from readFileToRows
      if (typeof XLSX === 'undefined') {
        alert("Error: SheetJS (XLSX) library is not loaded. This usually happens due to a blocked or missing internet connection. Please check your connection and reload the page.");
        throw new Error("XLSX library not defined.");
      }

      const name = file.name.toLowerCase();
      const buf = await file.arrayBuffer();

      if (name.endsWith(".csv")) {
        const text = new TextDecoder("utf-8").decode(buf);
        // Basic CSV parse using SheetJS
        const wb = XLSX.read(text, { type: "string" });
        const sheet = wb.Sheets[wb.SheetNames[0]];
        const rows = XLSX.utils.sheet_to_json(sheet, { defval: "" });
        return { rows, sheetNames: wb.SheetNames };
      }

      const wb = XLSX.read(buf, { type: "array" });
      const sheet = wb.Sheets[wb.SheetNames[0]];
      const rows = XLSX.utils.sheet_to_json(sheet, { defval: "" });
      return { rows, sheetNames: wb.SheetNames };
    }

    async function linkFile(type) {
      if (!window.showOpenFilePicker) {
        alert("Your browser doesn't support the File System Access API. Please use the 'Select' button instead.");
        return;
      }
      try {
        const [handle] = await window.showOpenFilePicker({
          id: 'import-file',
          types: [{ description: 'Spreadsheets', accept: { 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': ['.xlsx'], 'text/csv': ['.csv'] } }],
          multiple: false
        });
        state._handles[type] = handle;
        const file = await handle.getFile();
        await processFile(file, type);
        await saveLocal("link-file");
      } catch (e) { console.warn("File pick cancelled or failed", e); }
    }
    window.linkFile = linkFile;

    // Wrapper to handle file selection and store FileSystemFileHandle
    async function handleFileSelect(event, type) {
      const file = event.target.files[0];
      if (!file) return;
      // No need to get handle here, as linkFile handles it. This is for legacy file input.
      await processFile(file, type);
    }
    window.handleFileSelect = handleFileSelect;

    async function processFile(file, type) {
      const data = await readSheet(file);
      state.raw[type] = data.rows;
      state.columns[type] = extractColumns(data.rows);
      state.filesMeta[type] = {
        name: file.name,
        size: file.size,
        lastModified: file.lastModified,
        importDate: nowISO()
      };
      updateMetaUI();
      // Auto-switch to mapping if first file
      if (Object.values(state.raw).filter(x => x.length > 0).length === 1) {
        renderMappingUI();
      }
      await saveLocal("import");
    }


    function extractColumns(rows) {
      const set = new Set();
      rows.forEach(r => Object.keys(r || {}).forEach(k => set.add(k)));
      return Array.from(set).sort((a, b) => a.localeCompare(b));
    }

    function pickGuess(columns, candidates) {
      const norm = s => (s || "").toString().trim().toLowerCase().replace(/[\s\-_]/g, "");
      const cNorm = columns.map(c => ({ c, n: norm(c) }));
      for (const cand of candidates) {
        const n = norm(cand);
        const exact = cNorm.find(x => x.n === n);
        if (exact) return exact.c;
      }
      // partial match
      for (const cand of candidates) {
        const n = norm(cand);
        const partial = cNorm.find(x => x.n.includes(n) || n.includes(x.n));
        if (partial) return partial.c;
      }
      return "";
    }

    async function selectProjectFolder() {
      try {
        const handle = await window.showDirectoryPicker({ id: 'project-dir', mode: 'readwrite' });
        state._projectFolderHandle = handle;
        await saveHandle(handle, "projectFolderHandle");

        await syncProjectFolder(handle, true); // User initiated

        const label = document.getElementById("projectFolderName");
        if (label) {
          label.textContent = handle.name;
          label.className = "mini good";
        }
        saveLocal("project-folder-set");
      } catch (e) {
        if (e.name !== 'AbortError') console.error("Project folder selection failed", e);
      }
    }
    window.selectProjectFolder = selectProjectFolder;

    async function syncProjectFolder(folderHandle, userInitiated = false) {
      if (!folderHandle) return;
      try {
        if (await folderHandle.queryPermission({ mode: 'readwrite' }) !== 'granted') {
          if (!userInitiated) {
            updatePersistenceUI();
            return;
          }
          if (await folderHandle.requestPermission({ mode: 'readwrite' }) !== 'granted') return;
        }

        // Explicitly set as active handle
        state._projectFolderHandle = folderHandle;
        state._sourceDirHandle = folderHandle;

        // 1. MasterDB.csv
        try {
          const masterHandle = await folderHandle.getFileHandle("MasterDB.csv", { create: true });
          state._masterDbHandle = masterHandle;
          await saveHandle(masterHandle, "masterDbHandle");
          await loadFromMasterDB();
          await autoBackupMasterDB(); // Backup on connect/reconnect
        } catch (e) { console.error("Auto-link MasterDB failed", e); }

        // 2. Setting.json
        try {
          const settingsHandle = await folderHandle.getFileHandle("Setting.json", { create: true });
          state._settingsFileHandle = settingsHandle;
          await saveHandle(settingsHandle, "settingsFileHandle");
          await loadSettings();
        } catch (e) { console.error("Auto-link Setting.json failed", e); }

        updatePersistenceUI();
        if (userInitiated) {
          setTag(els.saveTag, "Project Folder Synced ‚úÖ", "good");
          setTimeout(() => checkAndAutoScan(), 1000);
        }
      } catch (e) {
        console.error("Project folder sync failed", e);
      }
    }
    window.syncProjectFolder = syncProjectFolder;

    function updateMetaUI() {
      const types = ['student', 'sclass', 'timetable', 'device'];
      types.forEach(t => {
        const el = document.getElementById("meta-" + t);
        if (!el) return;
        const meta = state.filesMeta[t];
        const handle = state._handles?.[t];
        if (meta) {
          el.innerHTML = `‚úÖ <b>${meta.name}</b> (${meta.importDate ? friendlyTime(meta.importDate).split(',')[0] : 'just now'})`;
          if (handle) el.innerHTML += ` <button class="btn secondary mini" style="padding:1px 4px; scale:0.8;" onclick="relinkFile('${t}')">üîÑ Re-sync</button>`;
        } else {
          el.innerHTML = `<span class="muted">No file selected</span>`;
        }
      });
    }

    async function relinkFile(type) {
      const handle = state._handles[type];
      if (!handle) return;
      try {
        if (await handle.queryPermission({ mode: 'read' }) !== 'granted') {
          if (await handle.requestPermission({ mode: 'read' }) !== 'granted') return;
        }
        const file = await handle.getFile();
        await processFile(file, type);
        alert(`Resynced ${file.name}`);
      } catch (e) {
        alert("Failed to resync: " + e.message);
      }
    }
    window.relinkFile = relinkFile;

    /** ========= Mapping UI ========= **/

    function renderMappingUI() {
      const hasStudent = state.columns.student.length > 0; // Changed from studentInfo
      if (!hasStudent) {
        els.mappingArea.innerHTML = `<div class="muted" style="font-size:13px;">Import files first, then click <b>Map & Merge</b>.</div>`;
        return;
      }

      // Default mapping guesses (user can change)
      const si = state.columns.student; // Changed from studentInfo
      const sc = state.columns.sclass;
      const tt = state.columns.timetable;
      const dv = state.columns.device;

      const prev = state.mapping || {};

      const mapping = {
        // StudentInfo (master)
        si_eqid: prev.si_eqid || pickGuess(si, ["EQ_Id", "EQID", "EQ ID", "EQID#", "Student ID", "EQID_Number"]),
        si_first: prev.si_first || pickGuess(si, ["Student_Given_Name", "FirstName", "First Name", "GivenName", "Given Name"]),
        si_last: prev.si_last || pickGuess(si, ["Student_Family_Name", "LastName", "Last Name", "Surname", "FamilyName", "Family Name"]),
        si_year: prev.si_year || pickGuess(si, ["Yr_Lvl_Cd", "Year", "YearLevel", "Year Level", "Grade", "Year_lvl"]),
        si_roll: prev.si_roll || pickGuess(si, ["Roll_Class", "Roll Class", "RollClass", "Home Group", "Form", "PC", "Pastoral Class"]),
        si_parentemail: prev.si_parentemail || pickGuess(si, ["Contact_Desc", "ParentEmail", "Parent Email", "Email Address", "Email", "Primary Email"]),
        si_contactable: prev.si_contactable || pickGuess(si, ["Receives Correspondence", "Contactable", "Contactable?", "Communication"]),
        si_tt_popout: prev.si_tt_popout || pickGuess(si, ["Popout Weekly Timetable", "Weekly Timetable Link", "Timetable Popout", "OneSchool Link"]),

        // StudentClass (links)
        sc_eqid: prev.sc_eqid || pickGuess(sc, ["EQ_Id", "EQID", "StudentID", "EQ ID"]),
        sc_classcode: prev.sc_classcode || pickGuess(sc, ["ClassCode", "Class Code", "Class", "Subject Class", "Timetable Code"]),
        sc_classname: prev.sc_classname || pickGuess(sc, ["ClassName", "Class Name", "Class", "Group"]),
        sc_teacher: prev.sc_teacher || pickGuess(sc, ["Teacher", "TeacherName", "Teacher Name"]),

        // Timetable (decode class codes)
        tt_classcode: prev.tt_classcode || pickGuess(tt, ["ClassCode", "Class Code", "Class", "Timetable Code"]),
        tt_classname: prev.tt_classname || pickGuess(tt, ["ClassName", "Class Name", "Group", "Description"]),
        tt_teacher: prev.tt_teacher || pickGuess(tt, ["Teacher", "TeacherName", "Teacher Name"]),
        tt_period: prev.tt_period || pickGuess(tt, ["Period", "P", "Slot", "Period No"]),
        tt_day: prev.tt_day || pickGuess(tt, ["Day", "Date", "Weekday"]),
        tt_start: prev.tt_start || pickGuess(tt, ["Start", "Start Time", "From"]),
        tt_end: prev.tt_end || pickGuess(tt, ["Finish", "End", "To", "Finish Time"]),
        tt_room: prev.tt_room || pickGuess(tt, ["Facility_Code", "Room", "RoomNo", "Location", "Space"]),
        tt_staffid: prev.tt_staffid || pickGuess(tt, ["Staff_MISID", "MISID", "Staff MISID", "Staff ID", "Teacher_MISID"]),

        // Device (optional)
        dv_join: prev.dv_join || (dv.length ? "EQ_Id" : ""), // or "Username" or "Serial"
        dv_eqid: prev.dv_eqid || pickGuess(dv, ["EQ ID", "EQ_Id", "EQID", "StudentID"]),
        dv_serial: prev.dv_serial || pickGuess(dv, ["Serial", "SerialNumber", "Serial Number", "Asset Tag"]),
        dv_type: prev.dv_type || pickGuess(dv, ["Type", "Model", "Device Type", "Device Model"]),
        dv_hostname: prev.dv_hostname || pickGuess(dv, ["Hostname", "Computer Name"]),
        dv_user: prev.dv_user || pickGuess(dv, ["Email Address", "Username", "User", "Email"]),
        dv_connected: prev.dv_connected || pickGuess(dv, ["Connected", "Last Seen", "Online"]),
        dv_working: prev.dv_working || pickGuess(dv, ["Working", "Status", "Health"]),
        dv_notes: prev.dv_notes || pickGuess(dv, ["Status", "Notes", "Comment", "Remark", "Device Status", "IT Status", "IT Notes", "Status Update"]),
      };

      state.mapping = mapping;

      function selectHtml(id, cols, value) {
        const opts = [`<option value="">(none)</option>`].concat(cols.map(c => `<option value="${escapeHtml(c)}" ${c === value ? "selected" : ""}>${escapeHtml(c)}</option>`));
        return `<select id="${id}">${opts.join("")}</select>`;
      }

      function section(title, body) {
        return `
      <div style="padding:12px; border:1px solid var(--line); border-radius:14px; background:var(--card2); margin-bottom:10px;">
        <div style="display:flex;justify-content:space-between;align-items:center;gap:10px;">
          <b style="font-size:13px;">${escapeHtml(title)}</b>
          <span class="mini">columns: ${body.match(/<select/g)?.length || 0}</span>
        </div>
        <div style="margin-top:10px; display:grid; grid-template-columns: 1fr 1fr; gap:10px;">
          ${body}
        </div>
      </div>
    `;
      }

      const html = `
    ${section("Student info DB (master list)", `
      <div><label>EQ_Id (required)</label>${selectHtml("map_si_eqid", si, mapping.si_eqid)}</div>
      <div><label>Year level</label>${selectHtml("map_si_year", si, mapping.si_year)}</div>
      <div><label>First name</label>${selectHtml("map_si_first", si, mapping.si_first)}</div>
      <div><label>Last name</label>${selectHtml("map_si_last", si, mapping.si_last)}</div>
      <div><label>Roll class / home group (optional)</label>${selectHtml("map_si_roll", si, mapping.si_roll)}</div>
      <div><label>Parent/Primary Email (for emails)</label>${selectHtml("map_si_parentemail", si, mapping.si_parentemail)}</div>
      <div><label>Contactable (Y/N - optional)</label>${selectHtml("map_si_contactable", si, mapping.si_contactable)}</div>
      <div><label>Popout Weekly Timetable (Link)</label>${selectHtml("map_si_tt_popout", si, mapping.si_tt_popout)}</div>
    `)}

    ${section("Student class (EQ_Id ‚Üí class)", `
      <div><label>EQ_Id (required)</label>${selectHtml("map_sc_eqid", sc, mapping.sc_eqid)}</div>
      <div><label>Class code (recommended)</label>${selectHtml("map_sc_classcode", sc, mapping.sc_classcode)}</div>
      <div><label>Class name (if no timetable)</label>${selectHtml("map_sc_classname", sc, mapping.sc_classname)}</div>
      <div><label>Teacher (optional)</label>${selectHtml("map_sc_teacher", sc, mapping.sc_teacher)}</div>
    `)}

    ${section("Timetable (class code ‚Üí class name)", `
      <div><label>Class code (recommended)</label>${selectHtml("map_tt_classcode", tt, mapping.tt_classcode)}</div>
      <div><label>Class name</label>${selectHtml("map_tt_classname", tt, mapping.tt_classname)}</div>
      <div><label>Teacher (Name)</label>${selectHtml("map_tt_teacher", tt, mapping.tt_teacher)}</div>
      <div><label>Teacher MISID (for emails)</label>${selectHtml("map_tt_staffid", tt, mapping.tt_staffid)}</div>
      <div><label>Period column</label>${selectHtml("map_tt_period", tt, mapping.tt_period)}</div>
      <div><label>Day column</label>${selectHtml("map_tt_day", tt, mapping.tt_day)}</div>
      <div><label>Room (optional)</label>${selectHtml("map_tt_room", tt, mapping.tt_room)}</div>
      <div><label>Start time (optional)</label>${selectHtml("map_tt_start", tt, mapping.tt_start)}</div>
      <div><label>Finish time (optional)</label>${selectHtml("map_tt_end", tt, mapping.tt_end)}</div>
    `)}

    <div style="padding:12px; border:1px solid var(--line); border-radius:14px; background:var(--card2);">
      <div style="display:flex;justify-content:space-between;align-items:center;gap:10px;">
        <b style="font-size:13px;">Device info (optional)</b>
        <span class="mini">${dv.length ? "imported" : "not imported"}</span>
      </div>

      ${dv.length ? `
      <div style="margin-top:10px; display:grid; grid-template-columns: 1fr 1fr; gap:10px;">
        <div>
          <label>Join method</label>
          <select id="map_dv_join">
            <option value="EQ_Id" ${mapping.dv_join === "EQ_Id" ? "selected" : ""}>Join by EQ_Id</option>
            <option value="Username" ${mapping.dv_join === "Username" ? "selected" : ""}>Join by Username</option>
            <option value="Serial" ${mapping.dv_join === "Serial" ? "selected" : ""}>Join by Serial</option>
          </select>
        </div>
        <div><label>EQ_Id column</label>${selectHtml("map_dv_eqid", dv, mapping.dv_eqid)}</div>
        <div><label>Username column</label>${selectHtml("map_dv_user", dv, mapping.dv_user)}</div>
        <div><label>Serial / asset tag column</label>${selectHtml("map_dv_serial", dv, mapping.dv_serial)}</div>
        <div><label>Device type / model</label>${selectHtml("map_dv_type", dv, mapping.dv_type)}</div>
        <div><label>Hostname</label>${selectHtml("map_dv_hostname", dv, mapping.dv_hostname)}</div>
        <div><label>Connected flag / last seen</label>${selectHtml("map_dv_connected", dv, mapping.dv_connected)}</div>
        <div><label>(none)</label>${selectHtml("map_dv_working", dv, mapping.dv_working)}</div>
        <div><label>Status</label>${selectHtml("map_dv_notes", dv, mapping.dv_notes)}</div>
      </div>
      ` : `
        <div class="muted" style="font-size:13px;margin-top:8px;">
          Import a device spreadsheet if you have one (S/N, status, on-network, etc.). You can still audit manually without it.
        </div>
      `}
    </div>

      ${section("üõ°Ô∏è Backup Settings", `
        <div style="grid-column: span 2;">
          <label style="display:flex; align-items:center; gap:8px; cursor:pointer;">
            <input type="checkbox" id="autoBackupToggle" ${state.backupSettings.autoOnOpen ? 'checked' : ''} onchange="toggleAutoBackup(this.checked)">
            Auto-backup to local folder on open
          </label>
        </div>
      `)}
    </div>

    <div class="row" style="margin-top:20px; padding:15px; border:1px solid var(--brand); border-radius:14px; background:rgba(37, 99, 235, 0.05); justify-content:space-between; align-items:center;">
      <div>
        <b style="color:var(--brand);">Comprehensive DB Export</b>
        <div class="mini muted">Combined CSV: Student info + Device + Scheduled Audit Slots.</div>
      </div>
      <button class="btn brand" onclick="exportCombinedDbCsv()">‚¨áÔ∏è Export Combined DB</button>
    </div>

    <div class="row" style="margin-top:12px;justify-content:space-between;">
      <button class="btn good" id="btnDoMerge">‚úÖ Merge now</button>
      <div class="mini muted">Once merged, you can filter + export/print.</div>
    </div>
  `;

      els.mappingArea.innerHTML = html;

      // Wire mapping inputs to state.mapping
      const bind = (id, key) => {
        const el = document.getElementById(id);
        if (!el) return;
        el.addEventListener("change", () => {
          state.mapping[key] = el.value;
          saveLocal("mapping-change");
        });
      };

      bind("map_si_eqid", "si_eqid");
      bind("map_si_first", "si_first");
      bind("map_si_last", "si_last");
      bind("map_si_year", "si_year");
      bind("map_si_roll", "si_roll");
      bind("map_si_parentemail", "si_parentemail");
      bind("map_si_contactable", "si_contactable");
      bind("map_si_tt_popout", "si_tt_popout");

      bind("map_sc_eqid", "sc_eqid");

      bind("map_sc_eqid", "sc_eqid");
      bind("map_sc_classcode", "sc_classcode");
      bind("map_sc_classname", "sc_classname");
      bind("map_sc_teacher", "sc_teacher");

      bind("map_tt_classcode", "tt_classcode");
      bind("map_tt_classname", "tt_classname");
      bind("map_tt_teacher", "tt_teacher");
      bind("map_tt_staffid", "tt_staffid");
      bind("map_tt_period", "tt_period");
      bind("map_tt_day", "tt_day");
      bind("map_tt_room", "tt_room");
      bind("map_tt_start", "tt_start");
      bind("map_tt_end", "tt_end");

      bind("map_dv_join", "dv_join");
      bind("map_dv_eqid", "dv_eqid");
      bind("map_dv_serial", "dv_serial");
      bind("map_dv_type", "dv_type");
      bind("map_dv_hostname", "dv_hostname");
      bind("map_dv_user", "dv_user");
      bind("map_dv_connected", "dv_connected");
      bind("map_dv_working", "dv_working");
      bind("map_dv_notes", "dv_notes");

      const btn = document.getElementById("btnDoMerge");
      if (btn) btn.addEventListener("click", () => {
        doMerge();
      });
    }

    /** ========= Merging ========= **/

    function normId(x) {
      return (x ?? "").toString().trim();
    }

    function asBool(v) {
      const s = (v ?? "").toString().trim().toLowerCase();
      if (s === "") return null;
      if (["1", "true", "t", "yes", "y", "connected", "on", "ok", "working"].includes(s)) return true;
      if (["0", "false", "f", "no", "n", "disconnected", "off", "not working", "broken", "fail"].includes(s)) return false;
      // if it looks like a date / last seen, treat as truthy but keep raw
      return null;
    }

    async function doMerge() {
      const m = state.mapping;
      if (!m?.si_eqid) {
        alert("Please map EQ_Id in Student info DB (required).");
        return;
      }

      const si = state.raw.student || []; // Changed from studentInfo
      const sc = state.raw.sclass || [];
      const tt = state.raw.timetable || [];
      const dv = state.raw.device || [];

      // Build lookup: timetable by class code
      const ttByCode = new Map();
      if (m.tt_classcode) {
        for (const r of tt) {
          const code = normId(r[m.tt_classcode]);
          if (!code) continue;
          ttByCode.set(code, {
            classCode: code,
            className: m.tt_classname ? (r[m.tt_classname] ?? "") : "",
            teacher: m.tt_teacher ? (r[m.tt_teacher] ?? "") : "",
            room: m.tt_room ? (r[m.tt_room] ?? "") : ""
          });
        }
      }

      // Build lookup: studentClass by EQ_Id => list of classes
      const classesByStudent = new Map();
      if (m.sc_eqid) {
        for (const r of sc) {
          const id = normId(r[m.sc_eqid]);
          if (!id) continue;

          const classCode = m.sc_classcode ? normId(r[m.sc_classcode]) : "";
          const classNameFallback = m.sc_classname ? (r[m.sc_classname] ?? "") : "";
          const teacherFallback = m.sc_teacher ? (r[m.sc_teacher] ?? "") : "";

          const ttMatch = classCode && ttByCode.get(classCode);

          const entry = {
            classCode: classCode || "",
            className: (ttMatch?.className || classNameFallback || "").toString(),
            teacher: (ttMatch?.teacher || teacherFallback || "").toString()
          };

          if (!classesByStudent.has(id)) classesByStudent.set(id, []);
          classesByStudent.get(id).push(entry);
        }
      }

      // Build device lookup
      const deviceByKey = new Map();
      const join = m.dv_join || "EQ_Id";

      const dvKey = (row) => {
        if (join === "EQ_Id") return m.dv_eqid ? normId(row[m.dv_eqid]) : "";
        if (join === "Username") return m.dv_user ? normId(row[m.dv_user]).toLowerCase() : "";
        if (join === "Serial") return m.dv_serial ? normId(row[m.dv_serial]).toLowerCase() : "";
        return "";
      };

      for (const r of dv) {
        const key = dvKey(r);
        if (!key) continue;
        // Keep first match, but store multiples if needed
        if (!deviceByKey.has(key)) deviceByKey.set(key, []);
        deviceByKey.get(key).push({
          serial: m.dv_serial ? (r[m.dv_serial] ?? "") : "",
          type: m.dv_type ? (r[m.dv_type] ?? "") : "",
          hostname: m.dv_hostname ? (r[m.dv_hostname] ?? "") : "",
          username: m.dv_user ? (r[m.dv_user] ?? "") : "",
          connectedRaw: m.dv_connected ? (r[m.dv_connected] ?? "") : "",
          workingRaw: m.dv_working ? (r[m.dv_working] ?? "") : "",
          notes: m.dv_notes ? (r[m.dv_notes] ?? "") : "", // Ensure Device Status is captured
          _source: r
        });
      }

      // Archiving: Keep existing students who were previously merged
      const existingStudents = state.merged.students || [];
      const existingById = new Map(existingStudents.map(s => [s.EQ_Id, s]));
      const newIds = new Set(si.map(r => normId(r[m.si_eqid])).filter(Boolean));

      // Merge students
      const merged = [];
      const processedIds = new Set();

      // 1. Add/Update students from new import
      for (const r of si) {
        const eqid = normId(r[m.si_eqid]);
        if (!eqid || processedIds.has(eqid)) continue;
        processedIds.add(eqid);

        const existing = existingById.get(eqid);

        let first = m.si_first ? (r[m.si_first] ?? "") : "";
        let last = m.si_last ? (r[m.si_last] ?? "") : "";

        // Fallback: split full name if both empty
        if (!first && !last) {
          const fullCol = pickGuess(state.columns.student, ["StudentName", "Full Name", "Student", "Name"]);
          const full = (fullCol ? (r[fullCol] ?? "") : "").toString();
          if (full.includes(",")) {
            const p = full.split(",");
            last = p[0].trim();
            first = (p[1] || "").trim();
          } else if (full.includes(" ")) {
            const p = full.split(" ");
            first = p[0].trim();
            last = p.slice(1).join(" ").trim();
          } else {
            first = full;
          }
        }
        const year = m.si_year ? (r[m.si_year] ?? "") : "";
        const roll = m.si_roll ? (r[m.si_roll] ?? "") : "";

        const classes = classesByStudent.get(eqid) || [];
        // Choose a primary class label for quick filtering (first, or roll class)
        const primaryClass = (classes[0]?.className || classes[0]?.classCode || roll || "").toString();

        // Device match by join method
        let deviceMatches = [];
        if (dv.length) {
          if (join === "EQ_Id") {
            deviceMatches = deviceByKey.get(eqid) || [];
          } else if (join === "Username") {
            const siUserCol = pickGuess(state.columns.student, ["Username", "User", "Login", "Email", "School Email", "Email Address"]);
            const user = siUserCol ? normId(r[siUserCol]).toLowerCase() : "";
            deviceMatches = user ? (deviceByKey.get(user) || []) : [];
          } else if (join === "Serial") {
            const siSerialCol = pickGuess(state.columns.student, ["Serial", "SerialNumber", "Serial Number", "Asset", "AssetTag", "Asset Tag"]);
            const serial = siSerialCol ? normId(r[siSerialCol]).toLowerCase() : "";
            deviceMatches = serial ? (deviceByKey.get(serial) || []) : [];
          }
        }

        // Pick first device as main (keep all as list)
        const device = deviceMatches[0] || null;

        // Audit fields stored separately (editable)
        const auditKey = "audit:" + eqid;
        const audit = (state._audit && state._audit[auditKey]) ? state._audit[auditKey] : (existing ? {
          connected: existing.AuditConnected,
          needsConnection: existing.AuditNeedsConnection,
          atHome: existing.AuditAtHome,
          needsEquity: existing.AuditNeedsEquity,
          notes: existing.AuditNotes
        } : null);

        const connectedGuess = device ? (asBool(device.connectedRaw) ?? null) : null;
        const workingGuess = device ? (asBool(device.workingRaw) ?? null) : null;

        merged.push({
          EQ_Id: eqid,
          FirstName: first,
          LastName: last,
          StudentName: [first, last].filter(Boolean).join(" ").trim(),
          YearLevel: year,
          RollClass: roll,
          ParentEmail: m.si_parentemail ? (r[m.si_parentemail] ?? "").toString().trim() : "",
          Contactable: m.si_contactable ? (r[m.si_contactable] ?? "").toString().trim() : "",
          TTPopout: m.si_tt_popout ? (r[m.si_tt_popout] ?? "").toString().trim() : "",

          PrimaryClass: primaryClass,
          Classes: classes, // list
          ClassCount: classes.length,

          DeviceSerial: device?.serial ?? "",
          DeviceType: device?.type ?? "",
          DeviceHostname: device?.hostname ?? "",
          DeviceUsername: device?.username ?? "",
          DeviceNotes: device?.notes ?? "",
          DeviceConnectedRaw: device?.connectedRaw ?? "",
          DeviceWorkingRaw: device?.workingRaw ?? "",
          DeviceMatches: deviceMatches,

          // Editable audit flags (priority: saved audit > parsed guess)
          AuditConnected: audit?.connected ?? connectedGuess,
          AuditNeedsConnection: audit?.needsConnection ?? false,
          AuditAtHome: audit?.atHome ?? false,
          AuditNeedsEquity: audit?.needsEquity ?? false,
          AuditNotes: audit?.notes ?? "",

          isArchived: false,
          _sourceStudent: r
        });
      }

      // 2. Add Archived students (those whom are missing from new import)
      for (const [id, s] of existingById.entries()) {
        if (!newIds.has(id)) {
          merged.push({
            ...s,
            isArchived: true
          });
        }
      }


      // Also keep device list for devices view
      const mergedDevices = [];
      for (const [key, list] of deviceByKey.entries()) {
        for (const d of list) {
          mergedDevices.push({
            JoinKey: key,
            Serial: d.serial,
            Type: d.type,
            Hostname: d.hostname,
            Username: d.username,
            ConnectedRaw: d.connectedRaw,
            WorkingRaw: d.workingRaw,
            Notes: d.notes
          });
        }
      }

      state.merged.students = merged;
      state.merged.devices = mergedDevices;
      state.lastMergedAt = nowISO();

      // Parent email fallback if missing in SI
      merged.forEach(s => {
        if (!s.ParentEmail && m.si_parentemail) {
          s.ParentEmail = (s._sourceStudent[m.si_parentemail] ?? "").toString().trim();
        }
      });

      // Build audit store (if missing)
      if (!state._audit) state._audit = {};

      try {
        state.lastMergedAt = nowISO();
        updateMetaUI();
        render();

        // Switch to dashboard automatically on first merge
        showSection('dashboard');

        await saveLocal("merge");
      } catch (e) {
        console.error("Merge/Save failure:", e);
        alert("An error occurred during the merge or save process. Check the console for details.\n\n" + e.message);
      }
      setTag(els.statusTag, "Merged", "good");
      updateSelectedCount();
    }

    function updateSelectedCount() {
      const el = document.getElementById("selectedCount");
      if (el) el.textContent = Object.keys(state.selectedStudents || {}).length;
    }

    function toggleSelection(val) {
      if (val) {
        const visible = getFilteredStudents();
        if (!state.selectedStudents) state.selectedStudents = {};
        visible.forEach(s => state.selectedStudents[s.EQ_Id] = true);
      } else {
        state.selectedStudents = {};
      }
      renderStudents();
      updateSelectedCount();
      saveLocal("selection-toggle");
    }

    function __toggleStudentSelection(eqid, val) {
      if (!state.selectedStudents) state.selectedStudents = {};
      if (val) state.selectedStudents[eqid] = true;
      else delete state.selectedStudents[eqid];
      updateSelectedCount();
      saveLocal("selection-change");
    }

    window.toggleSelection = toggleSelection;
    window.__toggleStudentSelection = __toggleStudentSelection;

    /** ========= Filters / Rendering ========= **/

    function refreshFilters() {
      // Populate year/class dropdowns from merged students
      const students = state.merged.students || [];

      const years = Array.from(new Set(students.map(s => (s.YearLevel ?? "").toString().trim()).filter(Boolean)))
        .sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));

      const classes = Array.from(new Set(students.flatMap(s => {
        const list = [];
        if (s.PrimaryClass) list.push(s.PrimaryClass);
        (s.Classes || []).forEach(c => {
          if (c.className) list.push(c.className);
          else if (c.classCode) list.push(c.classCode);
        });
        return list.map(x => x.toString().trim()).filter(Boolean);
      }))).sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));

      const yearSel = els.filterYear.value;
      const classSel = els.filterClass.value;

      els.filterYear.innerHTML = `<option value="">All years</option>` + years.map(y => `<option value="${escapeHtml(y)}">${escapeHtml(y)}</option>`).join("");
      els.filterClass.innerHTML = `<option value="">All classes</option>` + classes.map(c => `<option value="${escapeHtml(c)}">${escapeHtml(c)}</option>`).join("");

      if (years.includes(yearSel)) els.filterYear.value = yearSel;
      if (classes.includes(classSel)) els.filterClass.value = classSel;

      // Show tabs hint once we have data
      els.tabsInfo.style.display = students.length ? "block" : "none";
      render(); // Re-render dashboard after filters change
    }

    function getFilteredStudents() {
      const students = state.merged.students || [];
      const year = els.filterYear.value;
      const cls = els.filterClass.value;
      const dev = els.filterDevice.value;
      const q = (els.searchBox.value || "").trim().toLowerCase();

      const filtered = students.filter(s => {
        // Basic Filters
        if (year && (s.YearLevel ?? "").toString() !== year) return false;

        if (cls) {
          const allClasses = new Set();
          if (s.PrimaryClass) allClasses.add(s.PrimaryClass);
          (s.Classes || []).forEach(c => {
            if (c.className) allClasses.add(c.className);
            if (c.classCode) allClasses.add(c.classCode);
          });
          if (!allClasses.has(cls)) return false;
        }

        const hasDevice = !!(s.DeviceSerial || s.DeviceHostname || s.DeviceType || (s.DeviceMatches || []).length);
        const connected = s.AuditConnected;
        const needsConn = s.AuditNeedsConnection;
        const atHome = s.AuditAtHome;
        const needsEquity = s.AuditNeedsEquity; // Ensure correct property name from state

        if (dev === "missing" && hasDevice) return false;
        if (dev === "has" && !hasDevice) return false;
        // Filter for students who ARE NOT connected (show only issues)
        if (dev === "notConnected" && connected === true) return false;
        if (dev === "notWorking" && s.AuditWorking !== false) return false; // If we track working

        if (dev === "issues") {
          const hasIssue = (connected === false) || needsConn || atHome || needsEquity;
          if (!hasIssue) return false;
        }

        // Consolidated Search
        if (q) {
          const first = (s.FirstName || "").toLowerCase();
          const last = (s.LastName || "").toLowerCase();
          const full = (s.StudentName || "").toLowerCase();
          const id = (s.EQ_Id || "").toLowerCase();
          const serial = (s.DeviceSerial || "").toLowerCase();
          const hostname = (s.DeviceHostname || "").toLowerCase();
          const notes = ((s.DeviceNotes || "") + " " + (s.AuditNotes || "")).toLowerCase();

          const matchesName = first.includes(q) || last.includes(q) || full.includes(q);
          const matchesId = id.includes(q);
          const matchesDevice = serial.includes(q) || hostname.includes(q);
          const matchesNotes = notes.includes(q);

          const matchesClass = (s.Classes || []).some(c =>
            (c.classCode || "").toLowerCase().includes(q) ||
            (c.className || "").toLowerCase().includes(q)
          );

          if (!matchesName && !matchesId && !matchesDevice && !matchesClass && !matchesNotes) return false;
        }

        return true;
      });

      // De-duplicate by EQ_Id
      const seen = new Set();
      return filtered.filter(s => {
        if (seen.has(s.EQ_Id)) return false;
        seen.add(s.EQ_Id);
        return true;
      });
    }

    window.__setAudit = __setAudit;

    function bulkAudit(field, val) {
      const students = getFilteredStudents();
      if (!students.length) return;
      if (!confirm(`Apply "${field}: ${val}" to all ${students.length} filtered students?`)) return;

      for (const s of students) {
        const ak = "audit:" + s.EQ_Id;
        __setAudit(ak, field, val, s.EQ_Id, false); // Add 'false' to skip render per loop
      }
      render(); // Single render after bulk
      saveLocal("bulk-audit");
    }

    function __setAudit(auditKey, field, value, eqid, shouldRender = true) {
      if (!state._audit) state._audit = {};
      if (!state._audit[auditKey]) state._audit[auditKey] = { connected: null, needsConnection: false, atHome: false, needsEquity: false, notes: "" };

      if (field === "connected") state._audit[auditKey].connected = !!value;
      if (field === "needsConnection") state._audit[auditKey].needsConnection = !!value;
      if (field === "atHome") state._audit[auditKey].atHome = !!value;
      if (field === "needsEquity") {
        state._audit[auditKey].needsEquity = !!value;
        if (value === true) addAuditNote(eqid, "Equity Requested");
      }
      if (field === "notes") state._audit[auditKey].notes = (value ?? "").toString();

      // Update merged row in-memory
      const row = (state.merged.students || []).find(s => s.EQ_Id === eqid);
      if (row) {
        if (field === "connected") row.AuditConnected = !!value;
        if (field === "needsConnection") row.AuditNeedsConnection = !!value;
        if (field === "atHome") row.AuditAtHome = !!value;
        if (field === "needsEquity") {
          row.AuditNeedsEquity = !!value;
          if (value === true) addAuditNote(eqid, "Equity Requested");
        }
        if (field === "notes") row.AuditNotes = (value ?? "").toString();
      }

      if (shouldRender) {
        saveLocal("audit-edit");
        render(); // keep KPIs accurate
      }
    }

    function addAuditNote(eqid, text) {
      if (!text || !text.trim()) return;
      if (!state._auditHistory) state._auditHistory = {};
      if (!state._auditHistory[eqid]) state._auditHistory[eqid] = [];

      state._auditHistory[eqid].push({
        date: nowISO(),
        text: text.trim(),
        author: "System"
      });

      saveLocal("note-added");
      const mode = els.viewMode.value;
      if (mode === 'students') renderStudents();
      renderEquityTracking(); // Always refresh this if it's open elsewhere
    }
    window.addAuditNote = addAuditNote;

    function statusChip(label, value, kind) {
      if (value === true) return `<span class="chip"><span class="dot good"></span>${label}</span>`;
      if (value === false && kind === 'connected') return `<span class="chip"><span class="dot bad"></span>${label}: No</span>`;
      return "";
    }

    function escapeHtml(s) {
      return (s ?? "").toString()
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }

    function render() {
      const mode = els.viewMode.value;

      if (mode === "students") renderStudents();
      if (mode === "classes") renderClasses();
      if (mode === "year") renderYears();
      if (mode === "devices") renderDevices();
    }

    function updateKPIs(filteredStudents) {
      const total = filteredStudents.length;

      let missing = 0;
      let issues = 0;
      let audited = 0;
      let overdue = 0;
      const now = new Date();

      for (const s of filteredStudents) {
        const hasDevice = !!(s.DeviceSerial || s.DeviceHostname || s.DeviceType || (s.DeviceMatches || []).length);
        if (!hasDevice) missing++;

        const issue = (s.AuditConnected === false) || s.AuditNeedsConnection || s.AuditAtHome || s.AuditNeedsEquity;
        if (issue) issues++;

        if (s.AuditConnected === true && hasDevice) audited++;

        // Overdue: Has a ReturnDate, that date is in the past, and status is NOT "Picked up" (4)
        if (s.ReturnDate) {
          const rd = new Date(s.ReturnDate);
          const eqStatus = state._equityStatus?.[s.EQ_Id] || 0;
          if (rd < now && eqStatus !== 4) {
            overdue++;
          }
        }
      }

      els.kpiStudents.textContent = total.toString();
      els.kpiMissing.textContent = missing.toString();
      els.kpiIssues.textContent = issues.toString();
      els.kpiAudited.textContent = audited.toString();
      if (document.getElementById("kpiOverdue")) {
        document.getElementById("kpiOverdue").textContent = overdue.toString();
      }
    }

    window.setSort = (field) => {
      if (state.sortBy === field) {
        state.sortDir = state.sortDir === 'asc' ? 'desc' : 'asc';
      } else {
        state.sortBy = field;
        state.sortDir = 'asc';
      }
      renderStudents();
    };

    function renderAuditRow(s) {
      const ak = "audit:" + s.EQ_Id;
      const id = s.EQ_Id;
      return `
        <div class="auditBox" style="display:flex; flex-wrap:nowrap; gap:6px; align-items:center;">
          <label style="margin:0; cursor:pointer; font-size:11px; display:inline-flex; align-items:center; gap:2px;" title="Connected">
            <input type="checkbox" ${s.AuditConnected === true ? "checked" : ""}
              onchange="window.__setAudit('${escapeHtml(ak)}','connected', this.checked, '${escapeHtml(id)}')">
            1-Connüì∂
          </label>
          <label style="margin:0; cursor:pointer; font-size:11px; display:inline-flex; align-items:center; gap:2px;" title="Needs Connection">
            <input type="checkbox" ${s.AuditNeedsConnection ? "checked" : ""}
              onchange="window.__setAudit('${escapeHtml(ak)}','needsConnection', this.checked, '${escapeHtml(id)}')">
            2-Buildüõ†Ô∏è
          </label>
          <label style="margin:0; cursor:pointer; font-size:11px; display:inline-flex; align-items:center; gap:2px;" title="At Home">
            <input type="checkbox" ${s.AuditAtHome ? "checked" : ""}
              onchange="window.__setAudit('${escapeHtml(ak)}','atHome', this.checked, '${escapeHtml(id)}')">
            3-Homeüè†
          </label>
          <label style="margin:0; cursor:pointer; font-size:11px; display:inline-flex; align-items:center; gap:2px;" title="Needs Equity">
            <input type="checkbox" ${s.AuditNeedsEquity ? "checked" : ""}
              onchange="window.__setAudit('${escapeHtml(ak)}','needsEquity', this.checked, '${escapeHtml(id)}')">
            4-EqReqüíª
          </label>
        </div>
      `;
    }

    function renderStudents() {
      const rows = getFilteredStudents();
      const hintEl = document.getElementById("viewHint");

      if (rows.length === 0) {
        if (!state.raw.student?.length) { // Changed from studentInfo
          hintEl.innerHTML = "‚ùå <b>No student data loaded.</b> Go to <b>Imports</b> and load your files.";
        } else if (!state.merged.students?.length) {
          hintEl.innerHTML = "‚ö†Ô∏è <b>Not merged yet.</b> Go to <b>Imports</b> and click <b>Map & Merge</b>.";
        } else {
          hintEl.innerHTML = "üîç No students match the current filters.";
        }
        els.tbody.innerHTML = `<tr><td colspan="20" style="padding:40px; text-align:center; color:var(--muted);">${hintEl.innerHTML}</td></tr>`;
        els.rowsShown.textContent = "0";
        return;
      }
      hintEl.textContent = `Showing ${rows.length} students.`;

      // Split into sorting logic
      const sortBy = state.sortBy || 'LastName';
      const sortDir = state.sortDir || 'asc';

      rows.sort((a, b) => {
        let valA = a[sortBy] || "";
        let valB = b[sortBy] || "";

        // Handle numeric sort for YearLevel
        if (sortBy === 'YearLevel') {
          const nA = parseInt(valA) || 0;
          const nB = parseInt(valB) || 0;
          return sortDir === 'asc' ? nA - nB : nB - nA;
        }

        valA = valA.toString().toLowerCase();
        valB = valB.toString().toLowerCase();

        if (valA < valB) return sortDir === 'asc' ? -1 : 1;
        if (valA > valB) return sortDir === 'asc' ? 1 : -1;
        return 0;
      });

      updateKPIs(rows);

      const getSortIcon = (field) => {
        if (state.sortBy !== field) return '<span class="sort-icon">‚Üï</span>';
        return state.sortDir === 'asc' ? '<span class="sort-icon">‚ñ≤</span>' : '<span class="sort-icon">‚ñº</span>';
      };

      els.theadRow.innerHTML = `
        <tr>
          <th rowspan="2" style="width:30px; text-align:center;"><input type="checkbox" onchange="toggleSelection(this.checked)"></th>
          <th rowspan="2" class="nowrap sortable" onclick="setSort('EQ_Id')">EQ_Id ${getSortIcon('EQ_Id')}</th>
          <th rowspan="2" class="sortable" onclick="setSort('LastName')">Last Name ${getSortIcon('LastName')}</th>
          <th rowspan="2" class="sortable" onclick="setSort('FirstName')">First Name ${getSortIcon('FirstName')}</th>
          <th rowspan="2" class="nowrap sortable" onclick="setSort('YearLevel')">Year ${getSortIcon('YearLevel')}</th>
          <th rowspan="2">Classes</th>
          <th rowspan="2">Device</th>
          <th colspan="4" style="text-align:center; border-bottom:2px solid var(--line); padding:4px;">Audit Status</th>
          <th rowspan="2">Status</th>
        </tr>
        <tr style="background:var(--card2); font-size:10px;">
          <th style="padding:4px 2px; text-align:center; background:var(--card2); border-right:1px solid var(--line);">
            <div style="font-weight:bold; font-size:9px; margin-bottom:4px; white-space:nowrap;">1-Connected üì∂</div>
            <button class="btn secondary mini" style="padding:1px 2px; font-size:8px; margin-bottom:2px; display:block; width:100%;" onclick="bulkAudit('connected', true)">All</button>
            <button class="btn secondary mini" style="padding:1px 2px; font-size:8px; display:block; width:100%;" onclick="bulkAudit('connected', false)">None</button>
          </th>
          <th style="padding:4px 2px; text-align:center; background:var(--card2); border-right:1px solid var(--line);">
            <div style="font-weight:bold; font-size:9px; margin-bottom:4px; white-space:nowrap;">2-Needs Conn üõ†Ô∏è</div>
            <button class="btn secondary mini" style="padding:1px 2px; font-size:8px; margin-bottom:2px; display:block; width:100%;" onclick="bulkAudit('needsConnection', true)">All</button>
            <button class="btn secondary mini" style="padding:1px 2px; font-size:8px; display:block; width:100%;" onclick="bulkAudit('needsConnection', false)">None</button>
          </th>
          <th style="padding:4px 2px; text-align:center; background:var(--card2); border-right:1px solid var(--line);">
            <div style="font-weight:bold; font-size:9px; margin-bottom:4px; white-space:nowrap;">3-At Home üè†</div>
            <button class="btn secondary mini" style="padding:1px 2px; font-size:8px; margin-bottom:2px; display:block; width:100%;" onclick="bulkAudit('atHome', true)">All</button>
            <button class="btn secondary mini" style="padding:1px 2px; font-size:8px; display:block; width:100%;" onclick="bulkAudit('atHome', false)">None</button>
          </th>
          <th style="padding:4px 2px; text-align:center; background:var(--card2);">
            <div style="font-weight:bold; font-size:9px; margin-bottom:4px; white-space:nowrap;">4-Equity Req üíª</div>
            <button class="btn secondary mini" style="padding:1px 2px; font-size:8px; margin-bottom:2px; display:block; width:100%;" onclick="bulkAudit('needsEquity', true)">All</button>
            <button class="btn secondary mini" style="padding:1px 2px; font-size:8px; display:block; width:100%;" onclick="bulkAudit('needsEquity', false)">None</button>
          </th>
        </tr>
      `;

      els.tbody.innerHTML = rows.map(s => {
        const isArch = !!s.isArchived;
        const allCls = (s.Classes || []).map(c => escapeHtml(c.className || c.classCode)).filter(Boolean);
        const shownCls = allCls.slice(0, 1);
        const moreCount = allCls.length - 1;
        const classMore = moreCount > 0 ? `<button class="chip" style="border:none; padding:1px 4px; cursor:pointer;" onclick="alert('All classes:\\n${allCls.join('\\n')}')">+${moreCount}</button>` : "";

        const deviceLine = [s.DeviceType, s.DeviceSerial].filter(Boolean).join(" ‚Ä¢ ");
        const hasDevice = !!(s.DeviceSerial || s.DeviceHostname || s.DeviceType || (s.DeviceMatches || []).length);
        const devIcon = isArch ? `<span class="tag" style="padding:1px 4px; font-size:9px;">ARCHIVED</span>` : (hasDevice ? `<span class="dot good" title="Linked"></span>` : `<span class="dot bad" title="Missing"></span>`);

        const auditKey = "audit:" + s.EQ_Id;
        const ak = auditKey;
        const id = s.EQ_Id;
        const h = state._auditHistory?.[s.EQ_Id] || [];

        const archStyle = isArch ? "opacity:0.6; background:rgba(0,0,0,0.03);" : "";

        return `
      <tr style="height:32px; ${archStyle}">
        <td style="text-align:center;"><input type="checkbox" ${state.selectedStudents[s.EQ_Id] ? "checked" : ""} onchange="window.__toggleStudentSelection('${escapeHtml(s.EQ_Id)}', this.checked)"></td>
        <td class="nowrap" style="font-family:var(--mono); font-size:11px;">${escapeHtml(s.EQ_Id)}</td>
        <td class="nowrap" style="font-weight:700; cursor:pointer;" title="Double-click for details" ondblclick="showStudentDetails('${escapeHtml(s.EQ_Id)}')">${escapeHtml(s.LastName || s.StudentName || "(no last name)")}</td>
        <td class="nowrap" style="cursor:pointer;" title="Double-click for details" ondblclick="showStudentDetails('${escapeHtml(s.EQ_Id)}')">${escapeHtml(s.FirstName || "")}</td>
        <td class="nowrap">
          <span class="mini" style="font-size:11px;">${escapeHtml(s.YearLevel || "")}</span>
          <span class="mini muted" style="margin-left:4px;">${escapeHtml(s.RollClass || "")}</span>
        </td>
        <td>
          <div style="display:flex; align-items:center; gap:4px; white-space:nowrap;">
            ${shownCls.map(x => `<span class="chip" style="max-width:110px; text-overflow:ellipsis; overflow:hidden;">${x}</span>`).join("")}
            ${classMore}
          </div>
        </td>
        <td class="nowrap">
          <div style="display:flex; align-items:center; gap:5px;">
            ${devIcon}
            <span style="font-size:12px;">${escapeHtml(deviceLine || (isArch ? "Archived Info" : "No Device"))}</span>
          </div>
        </td>
        <td style="text-align:center;"><input type="checkbox" ${s.AuditConnected === true ? "checked" : ""} onchange="window.__setAudit('${escapeHtml(ak)}','connected', this.checked, '${escapeHtml(id)}')"></td>
        <td style="text-align:center;"><input type="checkbox" ${s.AuditNeedsConnection ? "checked" : ""} onchange="window.__setAudit('${escapeHtml(ak)}','needsConnection', this.checked, '${escapeHtml(id)}')"></td>
        <td style="text-align:center;"><input type="checkbox" ${s.AuditAtHome ? "checked" : ""} onchange="window.__setAudit('${escapeHtml(ak)}','atHome', this.checked, '${escapeHtml(id)}')"></td>
        <td style="text-align:center;"><input type="checkbox" ${s.AuditNeedsEquity ? "checked" : ""} onchange="window.__setAudit('${escapeHtml(ak)}','needsEquity', this.checked, '${escapeHtml(id)}')"></td>
        <td>
            <div style="font-size:10px; color:var(--brand); background:rgba(37,99,235,0.05); padding:4px; border-radius:4px; margin-bottom:4px; display:${s.DeviceNotes ? 'block' : 'none'};">
              <b>IT Status:</b> ${escapeHtml(s.DeviceNotes || "")}
            </div>
            <div style="max-height:80px; overflow-y:auto; border:1px solid var(--line); border-radius:4px; padding:4px; background:var(--bg);">
              ${h.map(note => `
                <div class="mini" style="margin-bottom:2px; border-bottom:1px solid #eee;">
                  <span class="muted" style="font-size:8px;">${new Date(note.date).toLocaleDateString()}</span>
                  <div style="font-size:9px;">${escapeHtml(note.text)}</div>
                </div>
              `).join("") || '<div class="mini muted">No audit notes</div>'}
            </div>
            <input type="text" placeholder="+ Add status update‚Ä¶" 
              style="font-size:10px; padding:2px 6px; width:120px; border-radius:4px; border:1px solid var(--line);"
              onkeyup="if(event.key==='Enter') { addAuditNote('${escapeHtml(s.EQ_Id)}', this.value); this.value=''; }">
          </div>
        </td>
      </tr>
    `;
      }).join("");


      els.rowsShown.textContent = rows.length.toString();
    }

    function groupCount(items, keyFn) {
      const map = new Map();
      for (const it of items) {
        const k = (keyFn(it) ?? "").toString().trim();
        if (!k) continue;
        map.set(k, (map.get(k) || 0) + 1);
      }
      return map;
    }

    function renderClasses() {
      const students = getFilteredStudents();
      updateKPIs(students);

      // Group by PrimaryClass (simple)
      const g = groupCount(students, s => s.PrimaryClass || "");
      const rows = Array.from(g.entries())
        .map(([k, v]) => {
          // Check if this class is selected in any slot
          const code = normId(k);
          const isSelected = Object.keys(state.chosenClasses || {}).some(key => key.startsWith(code + "|"));
          return { Class: k, Students: v, Selected: isSelected };
        })
        .sort((a, b) => (b.Selected - a.Selected) || b.Students - a.Students || a.Class.localeCompare(b.Class));

      els.viewHint.innerHTML = `Showing <b>class summary</b> (based on PrimaryClass). Use filters to narrow to a year or device issue.`;
      els.theadRow.innerHTML = `
        <tr>
          <th>Class</th>
          <th class="right">Students</th>
          <th class="right">Missing device</th>
          <th class="right">Issues</th>
        </tr>
      `;

      els.tbody.innerHTML = rows.map(r => {
        const inClass = students.filter(s => (s.PrimaryClass || "") === r.Class);
        const missing = inClass.filter(s => !(s.DeviceSerial || s.DeviceHostname || s.DeviceType || (s.DeviceMatches || []).length)).length;
        const issues = inClass.filter(s => (s.AuditConnected === false) || (s.AuditWorking === false)).length;

        return `
      <tr>
        <td><b>${escapeHtml(r.Class || "(blank)")}</b></td>
        <td class="right">${r.Students}</td>
        <td class="right">${missing}</td>
        <td class="right">${issues}</td>
      </tr>
    `;
      }).join("");

      els.rowsShown.textContent = rows.length.toString();
    }

    function renderYears() {
      const students = getFilteredStudents();
      updateKPIs(students);

      const g = groupCount(students, s => s.YearLevel || "");
      const rows = Array.from(g.entries())
        .map(([k, v]) => ({ Year: k, Students: v }))
        .sort((a, b) => a.Year.localeCompare(b.Year, undefined, { numeric: true }));

      els.viewHint.innerHTML = `Showing <b>year level summary</b>. Use the Class filter to drill down.`;
      els.theadRow.innerHTML = `
        <tr>
          <th>Year level</th>
          <th class="right">Students</th>
          <th class="right">Missing device</th>
          <th class="right">Issues</th>
        </tr>
      `;

      els.tbody.innerHTML = rows.map(r => {
        const inYear = students.filter(s => (s.YearLevel || "").toString() === r.Year);
        const missing = inYear.filter(s => !(s.DeviceSerial || s.DeviceHostname || s.DeviceType || (s.DeviceMatches || []).length)).length;
        const issues = inYear.filter(s => (s.AuditConnected === false) || (s.AuditWorking === false)).length;

        return `
      <tr>
        <td><b>${escapeHtml(r.Year || "(blank)")}</b></td>
        <td class="right">${r.Students}</td>
        <td class="right">${missing}</td>
        <td class="right">${issues}</td>
      </tr>
    `;
      }).join("");

      els.rowsShown.textContent = rows.length.toString();
    }

    function emailTeachers(type, value) {
      const ttRows = state.raw.timetable || [];
      const m = state.mapping;
      if (!m?.tt_staffid) {
        alert("Please map 'Teacher MISID' in the Imports tab first to use this feature.");
        return;
      }

      const searchPeriods = (type === 'period') ? (PERIOD_MAP[value] || [value]) : [];
      const misids = new Set();

      Object.keys(state.chosenClasses).forEach(key => {
        const [code, day, period] = key.split("|");

        let match = false;
        if (type === 'day') match = looseMatch(day, value);
        else if (type === 'period') match = searchPeriods.some(p => looseMatch(period, p));
        else if (type === 'week') match = true; // Collect all for week

        if (match) {
          const rec = ttRows.find(r => normId(r[m.tt_classcode]) === code && looseMatch(r[m.tt_day], day) && looseMatch(r[m.tt_period], period));
          if (rec && rec[m.tt_staffid]) {
            misids.add(normId(rec[m.tt_staffid]).toLowerCase());
          }
        }
      });

      if (misids.size === 0) {
        alert(`No teacher MISIDs found for the chosen classes for ${value}.`);
        return;
      }

      const emails = Array.from(misids).map(id => id + "@eq.edu.au");
      const bcc = emails.join(";");
      const subject = encodeURIComponent(type === 'week' ? "Device Audit - This Week" : `Device Audit - ${value}`);

      let bodyText = "";
      if (type === 'week') {
        const scheduleItems = [];
        const pOrd = { "HC": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8 };

        Object.keys(state.chosenClasses).forEach(key => {
          const [code, day, period] = key.split("|");
          const rec = ttRows.find(r => normId(r[m.tt_classcode]) === code && looseMatch(r[m.tt_day], day) && looseMatch(r[m.tt_period], period));
          scheduleItems.push({ code, day, period, room: rec?.[m.tt_room] || "" });
        });

        // Sort: Day, then Period
        const DAYS_SORT = ["Mon", "Tue", "Wed", "Thu", "Fri", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday"];
        scheduleItems.sort((a, b) => {
          const d1 = DAYS_SORT.indexOf(a.day), d2 = DAYS_SORT.indexOf(b.day);
          if (d1 !== d2 && d1 !== -1 && d2 !== -1) return d1 - d2;

          const getP = p => {
            if (p === "HC") return 0;
            const n = parseInt(p.replace(/\D/g, ''));
            return isNaN(n) ? 99 : n;
          };
          return getP(a.period) - getP(b.period);
        });

        const listStr = scheduleItems.map(i => `- ${i.day}, ${i.period}: ${i.code} ${i.room ? `(Room ${i.room})` : ""}`).join("\n");

        bodyText = `Hi Teachers,\n\nWe will be conducting a device audit in classes this week, starting tomorrow (Tuesday). Please ask students to have their devices ready for a quick check.\n\nThis will be a brief pop-in to classes. Apologies for the disruption, and thank you for your support.\n\nSchedule for Audit:\n${listStr}`;
      } else {
        bodyText = `Hi Teachers,\n\nWe are conducting a device audit for classes on ${value}. Please ensure students have their devices ready for inspection. This will be a brief pop in to classes ‚Äì apologies for the disruption.\n\nThank you.`;
      }

      window.location.href = `mailto:?bcc=${bcc}&subject=${subject}&body=${encodeURIComponent(bodyText)}`;
    }

    function renderDevices() {
      // Devices view uses device list; still allow search text
      const q = (els.searchBox.value || "").trim().toLowerCase();
      let rows = state.merged.devices || [];

      if (q) {
        rows = rows.filter(d => Object.values(d).join(" ").toLowerCase().includes(q));
      }

      updateKPIs(getFilteredStudents());

      els.viewHint.innerHTML = `Showing <b>devices</b> imported/linked. Search to find a serial/hostname quickly.`;
      els.theadRow.innerHTML = `
        <tr>
          <th>Join key</th>
          <th>Type</th>
          <th>Serial</th>
          <th>Hostname</th>
          <th>Username</th>
          <th>Connected</th>
          <th>Working</th>
          <th>Notes</th>
        </tr>
      `;

      els.tbody.innerHTML = rows.map(d => `
    <tr>
      <td style="font-family:var(--mono);">${escapeHtml(d.JoinKey)}</td>
      <td>${escapeHtml(d.Type)}</td>
      <td style="font-family:var(--mono);">${escapeHtml(d.Serial)}</td>
      <td>${escapeHtml(d.Hostname)}</td>
      <td>${escapeHtml(d.Username)}</td>
      <td>${escapeHtml(d.ConnectedRaw)}</td>
      <td>${escapeHtml(d.WorkingRaw)}</td>
      <td>${escapeHtml(d.Notes)}</td>
    </tr>
  `).join("");

      els.rowsShown.textContent = rows.length.toString();
    }

    function printChosenGroups(type, value) {
      // Handle 'week' type by searching all chosen keys
      const ttRows = state.raw.timetable || [];
      const m = state.mapping;
      const searchPeriods = (type === 'period') ? (PERIOD_MAP[value] || [value]) : [];

      const targetClasses = []; // List of { code, p, d, teacher, room, isAuto }
      const autoFilledCodes = [];

      Object.keys(state.chosenClasses).forEach(key => {
        const [code, day, period] = key.split("|");
        const val = state.chosenClasses[key];
        const isAuto = (typeof val === 'object' && val.type === 'auto') || val === 'auto';

        if (isAuto) autoFilledCodes.push(code);

        let match = false;
        if (type === 'day') match = looseMatch(day, value);
        else if (type === 'period') match = searchPeriods.some(p => looseMatch(period, p));
        else if (type === 'week') match = true;
        else if (type === 'auto') match = isAuto;

        if (match) {
          // Find original record for teacher/room
          const rec = ttRows.find(r => normId(r[m.tt_classcode]) === code && looseMatch(r[m.tt_day], day) && looseMatch(r[m.tt_period], period));
          targetClasses.push({
            code, day, period,
            teacher: rec?.[m.tt_teacher] || "",
            room: rec?.[m.tt_room] || "",
            isAuto
          });
        }
      });

      // Sort classes by period order (HC then 1-8)
      const pOrd = { "HC": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8 };
      targetClasses.sort((a, b) => {
        const getP = p => {
          if (p === "HC") return 0;
          const n = parseInt(p.replace(/\D/g, ''));
          return isNaN(n) ? 99 : n;
        };
        return getP(a.period) - getP(b.period);
      });

      if (targetClasses.length === 0) {
        alert(`No chosen classes found for ${type === 'auto' ? 'Auto-Fill' : (type === 'day' ? 'Day' : 'Period')}: ${value}`);
        return;
      }

      // Collect all students for these classes, ensuring each student appears only once globally
      const studentMap = new Map(); // EQ_Id -> { s, classes: [] }
      const allStudents = state.merged.students || [];

      targetClasses.forEach(tc => {
        const inThisClass = allStudents.filter(s => {
          const allClasses = new Set();
          if (s.PrimaryClass) allClasses.add(s.PrimaryClass);
          (s.Classes || []).forEach(c => {
            if (c.className) allClasses.add(c.className);
            else if (c.classCode) allClasses.add(c.classCode);
          });
          return allClasses.has(tc.code);
        });

        inThisClass.forEach(s => {
          if (!studentMap.has(s.EQ_Id)) {
            studentMap.set(s.EQ_Id, { s, matchedClasses: [] });
          }
          studentMap.get(s.EQ_Id).matchedClasses.push(`${tc.code} (${tc.period})`);
        });
      });

      const uniqueStudents = Array.from(studentMap.values()).map(x => x.s).sort((a, b) => a.StudentName.localeCompare(b.StudentName));

      const title = type === 'day' ? `Daily Audit: ${value}` : (type === 'auto' ? `Auto-Filled Audit Classes` : `Period Audit: ${value}`);
      const autoNote = (autoFilledCodes.length > 0) ? `
        <div class="legend" style="margin-top:20px; border-top:1px dotted #000; padding-top:10px; font-size:10px;">
          <b>Auto-Filled Missing Student Class List:</b><br/>
          The following classes were automatically added to ensure 100% student coverage: 
          <span style="font-family:monospace;">${[...new Set(autoFilledCodes)].join(", ")}</span>
        </div>
      ` : "";

      const win = window.open("", "_blank");
      win.document.write(`
      <html>
      <head>
        <title>${title}</title>
        <style>
          body { font-family: sans-serif; padding: 20px; line-height: 1.2; color: #000; font-size:12px; }
          h1 { font-size: 18px; margin: 0; }
          .header-info { margin-bottom: 15px; border-bottom: 2px solid #000; padding-bottom: 5px; display: flex; justify-content: space-between; align-items: flex-end; }
          .class-section { margin-bottom: 15px; }
          .class-section + .class-section { page-break-before: always; }
          .class-hd { background: #f0f0f0; padding: 6px 10px; border: 1px solid #000; border-bottom: none; font-weight: bold; display: flex; justify-content: space-between; }
          table { width: 100%; border-collapse: collapse; margin-top: 0; }
          th, td { border: 1px solid #000; padding: 4px 6px; text-align: left; font-size: 11px; }
          th { background: #eee; }
          .check-box { width: 20px; height: 14px; border: 1px solid #000; display: inline-block; vertical-align: middle; }
          .legend { margin-top: 10px; font-size: 10px; }
          @media print { .no-print { display: none; } }
          tr { page-break-inside: avoid; }
        </style>
      </head>
      <body>
        <div class="header-info">
          <div>
            <h1>${title}</h1>
            <div style="font-size:10px; margin-top:3px;">Audit Overview for ${value}</div>
          </div>
          <div style="text-align:right;">
            <div><b>Printed:</b> ${new Date().toLocaleDateString()}</div>
            <div><b>Students:</b> ${uniqueStudents.length}</div>
          </div>
        </div>
        
        ${(() => {
          const globalSeen = new Set();
          return targetClasses.map(tc => {
            // Get students for THIS class, but ONLY if they haven't been listed in a previous class grouping today
            const classStudents = uniqueStudents.filter(s => {
              if (globalSeen.has(s.EQ_Id)) return false;

              const allClasses = new Set();
              if (s.PrimaryClass) allClasses.add(s.PrimaryClass);
              (s.Classes || []).forEach(c => {
                if (c.className) allClasses.add(c.className);
                else if (c.classCode) allClasses.add(c.classCode);
              });

              if (allClasses.has(tc.code)) {
                globalSeen.add(s.EQ_Id);
                return true;
              }
              return false;
            });

            if (classStudents.length === 0) return "";

            return `
            <div class="class-section">
              <div class="class-hd">
                <span>Class: ${escapeHtml(tc.code)} (${escapeHtml(tc.period)}) ${tc.isAuto ? '‚ú®' : ''}</span>
                <span>Teacher: ${escapeHtml(tc.teacher)} | Room: ${escapeHtml(tc.room || "N/A")} | Students: ${classStudents.length}</span>
              </div>
              <table>
                <thead>
                  <tr>
                    <th style="width:80px;">EQ_Id</th>
                    <th>Student Name</th>
                    <th>Audit Status</th>
                    <th style="width:45px; text-align:center;">1-Conn.</th>
                    <th style="width:45px; text-align:center;">2-Needs</th>
                    <th style="width:45px; text-align:center;">3-Home</th>
                    <th style="width:45px; text-align:center;">4-Equity</th>
                    <th>Notes</th>
                  </tr>
                </thead>
                <tbody>
                  ${classStudents.map(s => {
              // Deduplicate class labels for the box (e.g. if they are in two periods that were merged)
              const distinctClasses = [...new Set(studentMap.get(s.EQ_Id).matchedClasses)];
              const labelStr = distinctClasses.length > 1 ? `<div class="mini muted" style="font-weight:normal; font-size:9px;">Also in: ${escapeHtml(distinctClasses.filter(x => !x.startsWith(tc.code)).join(", "))}</div>` : "";

              return `
                      <tr>
                        <td style="font-family:monospace;">${escapeHtml(s.EQ_Id)}</td>
                        <td><b>${escapeHtml(s.StudentName)}</b>${labelStr}</td>
                        <td style="font-size:9px;">
                          ${s.AuditConnected === true ? "üì∂ Connected<br>" : ""}
                          ${s.AuditNeedsConnection ? "üõ†Ô∏è Needs Conn.<br>" : ""}
                          ${s.AuditAtHome ? "üè† At Home<br>" : ""}
                          ${s.AuditNeedsEquity ? "üíª Needs Equity<br>" : ""}
                        </td>
                        <td style="text-align:center;"><div class="check-box"></div></td>
                        <td style="text-align:center;"><div class="check-box"></div></td>
                        <td style="text-align:center;"><div class="check-box"></div></td>
                        <td style="text-align:center;"><div class="check-box"></div></td>
                        <td style="font-size:9px;">
                          ${s.DeviceNotes ? `<div style="font-style:italic; font-size:8px; border-bottom:1px dotted #ccc; margin-bottom:2px;">[Imp] ${escapeHtml(s.DeviceNotes)}</div>` : ""}
                          ${escapeHtml(s.AuditNotes || "")}
                        </td>
                      </tr>
                    `;
            }).join("")}
                </tbody>
              </table>
            </div>`;
          }).join("");
        })()}

        ${autoNote}

        <div class="legend" style="margin-top:10px;"><b>1:</b> Conn, <b>2:</b> Needs Conn, <b>3:</b> Home, <b>4:</b> Equity</div>
        <div class="no-print" style="margin-top:20px;">
          <button onclick="window.print()" style="padding:8px 16px; cursor:pointer;">Print Now</button>
          <button onclick="window.close()" style="padding:8px 16px; margin-left:10px; cursor:pointer;">Close</button>
        </div>
      </body>
      </html>
      `);
      win.document.close();
    }

    function printClassList(classCode, period, day, teacher, room) {
      const students = (state.merged.students || []).filter(s => {
        const allClasses = new Set();
        if (s.PrimaryClass) allClasses.add(s.PrimaryClass);
        (s.Classes || []).forEach(c => {
          if (c.className) allClasses.add(c.className);
          if (c.classCode) allClasses.add(c.classCode);
        });
        return allClasses.has(classCode);
      }).sort((a, b) => a.StudentName.localeCompare(b.StudentName));

      if (students.length === 0) {
        alert("No students found for this class in the merged dataset.");
        return;
      }

      const win = window.open("", "_blank");
      win.document.write(`
      <html>
      <head>
        <title>Audit List - ${classCode}</title>
        <style>
          body { font-family: sans-serif; padding: 20px; line-height: 1.4; color: #000; }
          h1 { font-size: 20px; margin: 0; }
          .header-info { margin-bottom: 20px; border-bottom: 2px solid #000; padding-bottom: 10px; display: flex; justify-content: space-between; align-items: flex-end; }
          table { width: 100%; border-collapse: collapse; margin-top: 10px; }
          th, td { border: 1px solid #000; padding: 8px; text-align: left; font-size: 13px; }
          th { background: #eee; }
          .check-box { width: 30px; height: 18px; border: 1px solid #000; display: inline-block; vertical-align: middle; }
          .legend { margin-top: 20px; font-size: 12px; }
          @media print { .no-print { display: none; } }
        </style>
      </head>
      <body>
        <div class="header-info">
          <div>
            <h1>${escapeHtml(classCode)} Audit List</h1>
            <div style="margin-top:5px;"><b>Teacher:</b> ${escapeHtml(teacher)} | <b>Room:</b> ${escapeHtml(room || "N/A")}</div>
          </div>
          <div style="text-align:right;">
            <div><b>Day:</b> ${day}</div>
            <div><b>Period:</b> ${period}</div>
          </div>
        </div>
        <table>
          <thead>
            <tr>
              <th style="width:120px;">EQ_Id</th>
              <th>Student Name</th>
              <th style="width:60px; text-align:center;">1-Conn.</th>
              <th style="width:60px; text-align:center;">2-Needs</th>
              <th style="width:60px; text-align:center;">3-Home</th>
              <th style="width:60px; text-align:center;">4-Equity</th>
              <th style="width:100px;">Current Status</th>
              <th>Notes</th>
            </tr>
          </thead>
          <tbody>
            ${students.map(s => `
              <tr>
                <td style="font-family:monospace; font-size:11px;">${escapeHtml(s.EQ_Id)}</td>
                <td><b>${escapeHtml(s.StudentName)}</b></td>
                <td style="text-align:center;"><div class="check-box"></div></td>
                <td style="text-align:center;"><div class="check-box"></div></td>
                <td style="text-align:center;"><div class="check-box"></div></td>
                <td style="text-align:center;"><div class="check-box"></div></td>
                <td style="font-size:10px;">
                  ${s.AuditConnected === true ? "Connected<br>" : ""}
                  ${s.AuditNeedsConnection ? "Needs Conn.<br>" : ""}
                  ${s.AuditAtHome ? "At Home<br>" : ""}
                  ${s.AuditNeedsEquity ? "Needs Equity<br>" : ""}
                </td>
                <td style="font-size:10px;">
                  ${s.DeviceNotes ? `<div style="font-style:italic; font-size:9px; border-bottom:1px dotted #ccc; margin-bottom:2px;">[Imp] ${escapeHtml(s.DeviceNotes)}</div>` : ""}
                  ${escapeHtml(s.AuditNotes || "")}
                </td>
              </tr>
            `).join("")}
          </tbody>
        </table>
        <div class="legend">
          <b>Legend:</b> 1: Connected device, 2: Needs to be connected, 3: Device at home, 4: Needs an equity device.
        </div>
        <div class="no-print" style="margin-top:30px;">
          <button onclick="window.print()" style="padding:10px 20px; cursor:pointer;">Print Now</button>
          <button onclick="window.close()" style="padding:10px 20px; margin-left:10px; cursor:pointer;">Close</button>
        </div>
      </body>
      </html>
    `);
      win.document.close();
    }

    async function saveToMasterDB() {
      if (!state._masterDbHandle) return;
      try {
        const students = state.merged.students || [];
        if (!students.length) return;

        const cols = [
          "EQ_Id", "FirstName", "LastName", "StudentName", "YearLevel", "RollClass",
          "PrimaryClass", "DeviceSerial", "DeviceType", "DeviceHostname", "DeviceUsername",
          "DeviceNotes", "AuditConnected", "AuditNeedsConnection", "AuditAtHome",
          "AuditNeedsEquity", "AuditNotes", "isArchived", "ParentEmail", "TTPopout"
        ];

        const rows = students.map(s => {
          const r = {};
          cols.forEach(c => {
            let val = s[c];
            if (c === "Classes") val = (s.Classes || []).map(cl => cl.classCode).join(" | ");
            r[c] = val;
          });
          return r;
        });

        const csv = toCsv(rows, cols);
        const writable = await state._masterDbHandle.createWritable();
        await writable.write(csv);
        await writable.close();
        console.log("MasterDB.csv saved successfully.");
      } catch (e) {
        console.error("Failed to save to MasterDB.csv", e);
      }
    }

    async function loadFromMasterDB() {
      if (!state._masterDbHandle) return;
      try {
        const file = await state._masterDbHandle.getFile();
        const text = await file.text();
        if (!text.trim()) return;

        const workbook = XLSX.read(text, { type: 'string' });
        const sheet = workbook.Sheets[workbook.SheetNames[0]];
        const data = XLSX.utils.sheet_to_json(sheet);

        if (data.length > 0) {
          state.merged.students = data.map(d => ({
            ...d,
            AuditConnected: d.AuditConnected === "true",
            AuditNeedsConnection: d.AuditNeedsConnection === "true",
            AuditAtHome: d.AuditAtHome === "true",
            AuditNeedsEquity: d.AuditNeedsEquity === "true",
            isArchived: d.isArchived === "true",
            Classes: d.Classes ? d.Classes.split(" | ").map(c => ({ classCode: c })) : []
          }));
          refreshFilters();
          render();
          console.log("Loaded students from MasterDB.csv");
        }
      } catch (e) {
        console.error("Failed to load MasterDB.csv", e);
      }
    }

    async function saveSettings() {
      if (!state._settingsFileHandle) return;
      try {
        const settings = {
          prefixes: state.prefixes,
          mapping: state.mapping,
          bulkFilters: state.bulkFilters,
          chosenClasses: state.chosenClasses,
          backupSettings: state.backupSettings
        };
        const writable = await state._settingsFileHandle.createWritable();
        await writable.write(JSON.stringify(settings, null, 2));
        await writable.close();
        console.log("Setting.json saved successfully.");
      } catch (e) {
        console.error("Failed to save Setting.json", e);
      }
    }

    async function loadSettings() {
      if (!state._settingsFileHandle) return;
      try {
        const file = await state._settingsFileHandle.getFile();
        const text = await file.text();
        if (!text.trim()) return;

        const settings = JSON.parse(text);
        if (settings) {
          if (settings.prefixes) state.prefixes = settings.prefixes;
          if (settings.mapping) state.mapping = settings.mapping;
          if (settings.bulkFilters) state.bulkFilters = settings.bulkFilters;
          if (settings.chosenClasses) state.chosenClasses = settings.chosenClasses;
          if (settings.backupSettings) state.backupSettings = settings.backupSettings;

          // Update UI
          if (state.prefixes) {
            document.getElementById("pre_student").value = state.prefixes.student || "";
            document.getElementById("pre_sclass").value = state.prefixes.sclass || "";
            document.getElementById("pre_timetable").value = state.prefixes.timetable || "";
            document.getElementById("pre_device").value = state.prefixes.device || "";
          }
          renderMappingUI();
          render();
          console.log("Loaded configuration from Setting.json");
        }
      } catch (e) {
        console.error("Failed to load Setting.json", e);
      }
    }

    async function autoBackupMasterDB() {
      if (!state._masterDbHandle || !state.backupSettings.folderName) return;
      try {
        const folderHandle = await loadHandle("folderHandle");
        if (!folderHandle) return;

        // Ensure Backup subfolder exists
        const backupDir = await folderHandle.getDirectoryHandle("Backup", { create: true });

        const file = await state._masterDbHandle.getFile();
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const backupFileName = `MasterDB_Backup_${timestamp}.csv`;

        const backupFileHandle = await backupDir.getFileHandle(backupFileName, { create: true });
        const writable = await backupFileHandle.createWritable();
        await writable.write(await file.arrayBuffer());
        await writable.close();
        console.log(`Auto-backup created: ${backupFileName}`);
      } catch (e) {
        console.error("Auto-backup failed", e);
      }
    }

    function updatePersistenceUI() {
      const dbStatus = document.getElementById("statusMasterDb");
      const settingsStatus = document.getElementById("statusSettingsFile");

      if (dbStatus) {
        dbStatus.textContent = state._masterDbHandle ? `Linked: ${state._masterDbHandle.name} ‚úÖ` : "Not linked";
        if (state._masterDbHandle) dbStatus.style.color = "var(--good)";
      }
      if (settingsStatus) {
        settingsStatus.textContent = state._settingsFileHandle ? `Linked: ${state._settingsFileHandle.name} ‚úÖ` : "Not linked";
        if (state._settingsFileHandle) settingsStatus.style.color = "var(--brand)";
      }
    }

    async function autoBackupFlow() {
      await autoBackupMasterDB();
      setTag(els.saveTag, "Auto-backup: Done", "good");
      setTimeout(() => setTag(els.saveTag, "Local save: idle"), 2000);
    }


    /** ========= Export ========= **/

    function downloadText(filename, text) {
      const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    function toCsv(rows, cols) {
      const esc = v => {
        const s = (v ?? "").toString();
        if (/[",\n]/.test(s)) return `"${s.replaceAll('"', '""')}"`;
        return s;
      };
      const head = cols.map(esc).join(",");
      const body = rows.map(r => cols.map(c => esc(r[c])).join(",")).join("\n");
      return head + "\n" + body;
    }

    function exportCurrentViewCsv() {
      const mode = els.viewMode.value;
      if (mode === "students") {
        const rows = getFilteredStudents().map(s => ({
          EQ_Id: s.EQ_Id,
          StudentName: s.StudentName,
          YearLevel: s.YearLevel,
          RollClass: s.RollClass,
          PrimaryClass: s.PrimaryClass,
          Classes: (s.Classes || []).map(c => c.className || c.classCode).filter(Boolean).join(" | "),
          DeviceType: s.DeviceType,
          DeviceSerial: s.DeviceSerial,
          DeviceHostname: s.DeviceHostname,
          DeviceUsername: s.DeviceUsername,
          AuditWorking: s.AuditWorking,
          AuditConnected: s.AuditConnected,
          AuditNotes: s.AuditNotes
        }));
        const cols = Object.keys(rows[0] || { EQ_Id: "" });
        downloadText(`device-audit_students_${new Date().toISOString().slice(0, 10)}.csv`, toCsv(rows, cols));
        return;
      }

      if (mode === "classes") {
        const students = getFilteredStudents();
        const g = groupCount(students, s => s.PrimaryClass || "");
        const rows = Array.from(g.entries()).map(([Class, Students]) => {
          const inClass = students.filter(s => (s.PrimaryClass || "") === Class);
          const MissingDevice = inClass.filter(s => !(s.DeviceSerial || s.DeviceHostname || s.DeviceType || (s.DeviceMatches || []).length)).length;
          const Issues = inClass.filter(s => (s.AuditConnected === false) || (s.AuditWorking === false)).length;
          return { Class, Students, MissingDevice, Issues };
        }).sort((a, b) => b.Students - a.Students || a.Class.localeCompare(b.Class));
        downloadText(`device-audit_classes_${new Date().toISOString().slice(0, 10)}.csv`, toCsv(rows, ["Class", "Students", "MissingDevice", "Issues"]));
        return;
      }

      if (mode === "year") {
        const students = getFilteredStudents();
        const g = groupCount(students, s => s.YearLevel || "");
        const rows = Array.from(g.entries()).map(([YearLevel, Students]) => {
          const inYear = students.filter(s => (s.YearLevel || "").toString() === YearLevel);
          const MissingDevice = inYear.filter(s => !(s.DeviceSerial || s.DeviceHostname || s.DeviceType || (s.DeviceMatches || []).length)).length;
          const Issues = inYear.filter(s => (s.AuditConnected === false) || (s.AuditWorking === false)).length;
          return { YearLevel, Students, MissingDevice, Issues };
        }).sort((a, b) => a.YearLevel.localeCompare(b.YearLevel, undefined, { numeric: true }));
        downloadText(`device-audit_years_${new Date().toISOString().slice(0, 10)}.csv`, toCsv(rows, ["YearLevel", "Students", "MissingDevice", "Issues"]));
        return;
      }

      if (mode === "devices") {
        const q = (els.searchBox.value || "").trim().toLowerCase();
        let rows = (state.merged.devices || []);
        if (q) rows = rows.filter(d => Object.values(d).join(" ").toLowerCase().includes(q));
        const cols = ["JoinKey", "Type", "Serial", "Hostname", "Username", "ConnectedRaw", "WorkingRaw", "Notes"];
        downloadText(`device-audit_devices_${new Date().toISOString().slice(0, 10)}.csv`, toCsv(rows, cols));
        return;
      }
    }

    function exportCombinedDbCsv() {
      const students = state.merged.students || [];
      if (!students.length) {
        alert("No merged data to export. Please import and merge files first.");
        return;
      }

      // Build a map of audit slots for each student
      const studentAuditSlots = new Map(); // EQ_Id -> Set of "Day Period (Room)"
      const chosenKeys = Object.keys(state.chosenClasses || {});
      const ttRows = state.raw.timetable || [];
      const m = state.mapping;

      chosenKeys.forEach(key => {
        const [code, day, period] = key.split("|");
        const rec = ttRows.find(r => normId(r[m.tt_classcode]) === code && looseMatch(r[m.tt_day], day) && looseMatch(r[m.tt_period], period));
        const room = rec ? (rec[m.tt_room] || "") : "";
        const slotDesc = `${day} P${period}${room ? ` (${room})` : ""}`;

        students.forEach(s => {
          const isMember = (s.Classes || []).some(c => normId(c.classCode) === code);
          if (isMember) {
            if (!studentAuditSlots.has(s.EQ_Id)) studentAuditSlots.set(s.EQ_Id, new Set());
            studentAuditSlots.get(s.EQ_Id).add(slotDesc);
          }
        });
      });

      const rows = students.map(s => ({
        EQ_Id: s.EQ_Id,
        Name: s.StudentName,
        Year: s.YearLevel,
        RollClass: s.RollClass,
        ParentEmail: s.ParentEmail || "",
        DeviceType: s.DeviceType,
        Serial: s.DeviceSerial,
        Hostname: s.DeviceHostname,
        User: s.DeviceUsername,
        Connected: s.AuditConnected === true ? "YES" : (s.AuditConnected === false ? "NO" : "Unknown"),
        NeedsConn: s.AuditNeedsConnection ? "YES" : "NO",
        AtHome: s.AuditAtHome ? "YES" : "NO",
        NeedsEquity: s.AuditNeedsEquity ? "YES" : "NO",
        Notes: s.AuditNotes || "",
        AuditSchedule: Array.from(studentAuditSlots.get(s.EQ_Id) || []).join(" | ")
      }));

      const cols = ["EQ_Id", "Name", "Year", "RollClass", "ParentEmail", "DeviceType", "Serial", "Hostname", "User", "Connected", "NeedsConn", "AtHome", "NeedsEquity", "Notes", "AuditSchedule"];
      downloadText(`combined_audit_db_${state.dbSuffix}_${new Date().toISOString().slice(0, 10)}.csv`, toCsv(rows, cols));
    }

    /** ========= Wiring ========= **/

    // Removed old event listeners for fileStudent, fileClass, fileTimetable, fileDevice
    // The new HTML uses onchange="handleFileSelect(event, 'type')" or onclick="linkFile('type')" directly.

    els.btnMapMerge.addEventListener("click", () => {
      renderMappingUI();
    });

    els.btnClear.addEventListener("click", () => {
      if (confirm("Clear everything saved locally and reload?")) clearAll();
    });

    els.viewMode.addEventListener("change", () => { render(); saveLocal("view-change"); });
    els.filterYear.addEventListener("change", () => { render(); saveLocal("year-filter"); });
    els.filterClass.addEventListener("change", () => { render(); saveLocal("class-filter"); });
    els.filterDevice.addEventListener("change", () => { render(); saveLocal("device-filter"); });
    els.searchBox.addEventListener("input", () => {
      // light debounce
      clearTimeout(window.__qTimer);
      window.__qTimer = setTimeout(() => { render(); saveLocal("search"); }, 500);
    });

    els.btnExportCsv.addEventListener("click", () => {
      exportCurrentViewCsv();
    });

    els.btnQuickSave.addEventListener("click", () => saveLocal("manual-save"));

    els.btnDownloadJson.addEventListener("click", () => {
      downloadText(`device-audit_backup_${new Date().toISOString().slice(0, 10)}.json`, JSON.stringify({ state, exportedAt: nowISO() }, null, 2));
    });

    // Start
    loadLocal();
    updateMetaUI();
    renderMappingUI();
    render();
  </script>
</body>

</html>
